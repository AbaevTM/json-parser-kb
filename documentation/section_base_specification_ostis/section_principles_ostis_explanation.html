<p>В основе предлагаемого нами подхода к созданию технологии проектирования интеллектуальных систем лежат следующие принципы.
</p>

<p><b>1. Принцип использования опыта наиболее продвинутых технологий</b>
</p>

<p><b>( Использование опыта наиболее продвинутых технологий)</b></p>

<p>В первую очередь, имеется в виду технология проектирования микросхем, которая за последнее время обеспечила существенное сокращение времени и повышение качества разработок,
</p>

<ol type="1">

<li>благодаря созданию языковых средств формального описания проектируемых микросхем на разных уровнях детализации,</li>

<li>благодаря четкому разделению процесса разработки формальных описаний микросхем и процесса их реализации по заданным формальным описаниям, </li>

<li>благодаря созданию мощных и доступных библиотек формальных описаний типовых (многократно используемых) компонентов микросхем. </li>

</ol>

<p>
Для того, чтобы аналогичным образом построить технологию проектирования интеллектуальных систем, необходимо
</p>

<ol type="1">

<li>создать языковые средства полного унифицированного формального описания интеллектуальных систем, </li>

<li>четко отделить разработку полного унифицированного формального описания проектируемой интеллектуальной системы от разработки различных вариантов интерпретации таких формальных описаний интеллектуальных систем, </li>

</ol>

<p>
создать библиотеку формальных описаний типовых (многократно используемых) компонентов интеллектуальных систем. Но для того, чтобы такая библиотека была создана, необходимо обеспечить <b>интегрируемость</b> (семантическую совместимость) указанных компонентов интеллектуальных систем.
</p>

<p><b>2. Принцип ориентации на графодинамические модели обработки информации</b>
</p>

<p>В качестве формальной основы проектируемых интеллектуальных систем предлагается использовать <b>графодинамические модели обработки информации</b>.
</p>

<p>Графодинамическая модель обработки информации трактует процесс обработки информации как процесс преобразования графовой структуры, в ходе которого меняется не только состояние элементов этой графовой структуры, но и конфигурация этой структуры (появляются или удаляются её вершины, а также связи между ними). Заметим, что для создания графодинамических моделей обработки информации недостаточно тех видов графовых структур, которые в настоящее время исследуются в теории графов. Нам потребуется  не только увеличение числа компонентов, инцидентных ребру (т. е. переход от ребра к <b>гиперребру</b>), но и увеличение числа компонентов инцидентных дуге (т. е. переход от дуги к <b>гипердуге</b>, которая по сути является графовой трактовкой многоместного кортежа). Нам потребуются не только  ребра, гиперребра, дуги, гипердуги, компонентами которых являются вершины графовой структуры, но и ребра, гиперребра, дуги, гипердуги, компонентами которых являются другие ребра, гиперребра, дуги и гипердуги. Нам потребуются такие связующие элементы графовых структур, которые задают целые фрагменты (подструктуры) заданной графовой структуры, в состав которых входят соответствующие вершины, ребра, гиперребра, дуги, гипердуги [Попков, 1986].
</p>

<p>Приведем общее определение графовой структуры, на основе которого можно строить практически полезные графодинамические модели обработки информации. 
</p>

<p>Графовая структура G задается пятеркой  < V, C, K, M, I >, где
</p>

<p>V – множество <b>вершин</b> (первичных элементов, терминальных элементов);
</p>

<p>C – множество <b>связующих элементов</b> графовой структуры, каждый из которых задает некоторый фрагмент графовой структуры;
</p>

<p>K – множество <b>ключевых вершин</b> графовой структуры, каждая из которых задает некоторый класс эквивалентных (однотипных) в определенном смысле элементов графовой структуры (K ⊂ V);
</p>

<p>M – множество <b>меток</b> элементов (алфавит элементов) графовой структуры, каждая из которых задает некоторый базовый класс эквивалентных в определенном смысле элементов графовой структуры. К таким классам элементов, в частности, относятся:
</p>

<ul type="disc">

<li>класс всех вершин графовой структуры;</li>
<li>класс всех связующих элементов графовой структуры;</li>
<li>класс всех ключевых вершин графовой структуры;</li>
<li>класс всех меток графовой структуры;</li>
<li>класс всех используемых в графовой структуре <b>отношений инцидентности</b> элементов графовой структуры.</li>

</ul> 

<p>I –  множество используемых в графовой структуре отношений инцидентности элементов. Все эти отношения инцидентности являются бинарными ориентированными отношениями. Среди этих отношений выделим:
</p>

<ul type="disc">

<li>отношения инцидентности вершин. Примером такого отношения является последовательность символов в строке символов;</li>

<li>отношения инцидентности, каждая пара которых связывает связующий элемент графовой структуры с элементом (компонентом) того фрагмента, который задается этим связующим элементом. Подчеркнем, что компонентами связующего элемента могут быть элементы графовой структуры любого вида (вершины, связующие элементы, метки, отношения инцидентности). Подчеркнем также, что компоненты одного и того же связующего элемента могут выполнять разные роли в рамках соответствующего фрагмента графовой структуры, который задается связующим элементом. Указанные роли соответствуют разным отношениям инцидентности, входящим во множество I;</li>

<li>отношения инцидентности, каждая пара которых связывает ключевую вершину графовой структуры с тем элементом графовой структуры, который входит в класс элементов, задаваемый этой ключевой вершиной. Подчеркнем, что элементами, инцидентными ключевой вершине, могут быть элементы графовой структуры любого вида;</li>

<li>отношения инцидентности, каждая пара которых связывает метку графовой структуры с тем элементом графовой структуры, который имеет указанную метку. Подчеркнем, что элементами, инцидентными метке, могут быть элементы графовой структуры любого вида.</li>

</ul>

<p>Заметим, что связь каждого отношения инцидентности (каждого элемента множества I) с соответствующими парами инцидентности и связь каждой пары инцидентности с элементами графовой структуры, соединяемыми этой парой инцидентности, можно условно считать неявно задаваемыми связями инцидентности более низкого уровня.
</p>

<p>
Заметим также, что каждую графовую структуру G мы будем трактовать как множество всех элементов, входящих в её состав: </p>

<p>G = ( V &cup; C &cup; K &cup; M &cup; I ). Таким образом, в число элементов графовой структуры входят все её вершины (в том числе ключевые), связующие элементы, метки и отношения инцидентности.
</p>

<p>
Заметим также, что множество связующих элементов графовой структуры можно разбить на:</p>

<ul type="disc">

<li>множество <b>связок</b> (простых связующих элементов);</li>

<li>множество <b>подструктур</b>, каждая из которых задает фрагмент графовой структуры, в состав которого входят такие связующие элементы, которые связывают элементы графовой структуры, входящие в указанный фрагмент.</li>

</ul>

<p>В свою очередь, по признаку ориентированности множество связок можно разбить на:</p>

<ul type="disc">

<li>множество <b>ориентированных связок</b>, некоторые компоненты которых выполняют в рамках этих связок <u>разные роли</u>;</li>

<li>множество <b>неориентированных связок</b>, все компоненты которых выполняют в рамках этих отношений связок <u>одинаковые роли</u>.</li>

</ul>

<p>
Важным частным случаем ориентированной связки является <b>кортеж</b>. Кортеж задает такое подмножество элементов графовой структуры, в котором роли всех элементов пронумерованы. То есть в рамках указанного подмножества имеется элемент, который в этом подмножестве выполняет роль первого элемента (первого компонента), имеется элемент, который в этом подмножестве выполняет роль второго элемента (второго компонента) и т. д.</p>

<p>Если в графовой структуре имеются кортежи, то в число её отношений инцидентности должны входить следующие отношения:
</p>

<ul type="disc">

<li>быть первым компонентом;</li>

<li>быть вторым компонентом;</li>

<li>быть третьим компонентом;</li>

<li>и т. д.</li>

</ul>

<p>
По количеству компонентов множество связок можно разбить на:</p>

<ul type="disc">

<li>множество <b>унарных связок</b> (одноместных, однокомпонентных);</li>

<li>множество <b>бинарных связок</b> (двухместных, двухкомпонентных);</li>

<li>множество <b>многокомпонентных связок</b> (многоместных), имеющих более двух компонентов.</li>

</ul>

<p>Неориентированные бинарные связки будем называть <b>ребрами</b>, ориентированные – <b>дугами</b>. Неориентированные многокомпонентные связки будем называть <b>гиперребрами</b>, а ориентированные – <b>гипердугами</b>.
</p>

<p>Множество связующих элементов графовой структуры можно трактовать как подмножество <b>шкалы множеств</b>, заданной над множеством 
</p>

<p>(V &cup; M &cup; I).
</p>

<p>Шкала множеств (H) над указанным множеством определяется рекурсивно:</p>

<ol type="1">

<li><i>H &sup; ( V &cup; M &cup; I )</i></li>

<li><i>если hj1, hj2, …, hjn &isin; H <br>то { hj1, hj2, …, hjn } &isin; H</i>
<br>/* т. е. любое множество, состоящее из любых элементов шкалы множеств, само также является одним из элементов шкалы множеств */
</li>

<li>если <i>hj1, hj2, …, hjn &isin; H;  ij1, ij2, …, ije &isin; I</i>
<br>то множество <i>hj = { hj1, hj2, …, hjn }</i>, между которым и множеством <i>{ ij1, ij2, …, ije }</i> задано произвольное соответствие, определяющее то или иное распределение ролей между элементами множества <i>hj</i>, также является элементом шкалы (т. е. <i>hj &isin; H</i>)
</li>

</ol>

<p>Какие вопросы ассоциируются с рассмотрением графодинамической модели (графодинамической парадигмы) обработки информации:</p>

<ul type="disc">

<li>Можно ли на основе теории графов построить <b>универсальную абстрактную модель обработки информации</b>, которая могла бы конкурировать с абстрактной машиной фон Неймана, лежащей в основе традиционных компьютерных систем;</li>

<li>Нужно ли это делать, какими преимуществами эта модель обладает по сравнению с абстрактной машиной фон Неймана. Какими преимуществами обладают системы, создаваемые на основе этой модели. Что принципиально нового дает графодинамическая парадигма обработки информации;</li>

<li>Есть ли к этому предпосылки;</li>

<li>Можно ли различные модели решения задач (в том числе различные логические исчисления) формально описать в виде графодинамических моделей обработки информации и можно ли обеспечить совместимость (интегрируемость) таких графодинамических моделей.</li>

</ul>

<p>
Интерес к графодинамическим моделям обработки информации имеет достаточно длительную историю. Для подтверждения этого достаточно отметить:</p>

<ul type="disc">

<li>Предложенное А.Н. Колмогоровым уточнение понятия алгоритма [Колмогоров, 1958];</li>

<li>Работы школы М.А. Айзермана по графодинамике [Айзерман, 1988];</li>

<li>Исследования по графовым грамматикам [Петров, 1987];</li>

<li>Исследования по теории программирования и CASE-технологиям [Касьянов, 2003];</li>

<li>Разработка параллельных моделей обработки информации [Котов, 1966];</li>

<li>Предложенные В.Б. Борщевым и М.В. Хомяковым клубные системы и вегетативная машина [Борщев, 1983].</li>

</ul>

<p>Для разработки графодинамических моделей обработки информации необходимо рассматривать графовую структуру с позиций семиотики и трактовать её как <b>знаковую структуру</b> (текст), представляющую собой систему взаимосвязанных знаков. Такая трактовка графовых структур позволяет "вдохнуть" семантику в теорию графов.
</p>

<p>Действительно, почему тексты обязательно должны быть линейными (т. е. цепочками символов). Но, как только мы введем понятие <b>графового языка</b> (т. е. языка, текстами которого являются в общем случае графовые структуры различной конфигурации), возникают следующие вопросы:
</p>

<ul type="disc">

<li>В чем преимущество графовых языков по сравнению с традиционными линейными языками, текстами которых являются цепочки (строки) символов;</li>

<li>Можно ли построить <b>универсальный графовый язык</b>, обеспечивающий представление информации (знаний) любого семантического вида;</li>

<li>Можно ли в универсальном графовом языке сделать так, чтобы множество всех меток, используемых во всех графовых структурах, являющихся текстами универсального графового языка, было конечным.</li>

</ul>

<p>Говоря о графовых языках, следует подчеркнуть то, что графовые структуры, являющиеся текстами таких языков, представляют собой абстрактные математические структуры, не уточняющие (не детализирующие) способ их материального представления (например, способ кодирования в компьютерной памяти, способ графического изображения, ориентированного на человеческое восприяетие). То есть графовая структура как абстрактный математический объект и её, например, графическое представление – это принципиально разные вещи. Из этого, в частности, следует, что каждому графовому языку может соответствовать несколько языков, использующих разные способы представления (кодирования, изображения) текстов этого графового языка.
</p>

<p>Накопленный опыт развития и применения теории графов и все полученные в ней результаты становятся хорошим математическим фундаментом для разработки различных графовых языков и различных графодинамических моделей обработки информации, а также для создания теории таких языков и моделей. На стыке теории графов и семиотики может появиться очень интересный раздел семиотики – <b>графовая семиотика</b>.
</p>

<p><b>3. Принцип ориентации на параллелелизм и асинхронность в графодинамических моделях</b>
</p>

<p>В качестве формальной основы проектируемых интеллектуальных систем предлагается использовать графодинамические модели специального вида, ориентированные на <b>параллельную и асинхронную</b> обработку информации. 
</p>

<p>Почему акцентируется внимание на <b>параллельных</b> графодинамических моделях. Во-первых, потому, что без организации параллельной обработки информации невозможно рассчитывать на необходимую производительность подавляющего числа практически полезных интеллектуальных систем. Во-вторых, потому, что  целый ряд исследований [Котов, 1966] показал перспективность создания параллельных моделей обработки информации именно на основе графодинамического подхода.
</p>

<p>Почему отдается предпочтение <b>асинхронному</b> варианту управления обработкой информации. Потому, что  асинхронные модели обработки информации являются более гибкими, их легче интегрировать и наращивать новыми функциональными возможностями.
</p>

<p>Графодинамическая модель параллельной асинхронной обработки информации, которую будем также называть <b>графодинамической параллельной асинхронной машиной</b>, трактуется нами как абстрактная <b>многоагентная система</b>, состоящая из:</p>

<ul type="disc">

<li>абстрактной <b>графодинамической памяти</b>, в которой хранятся обрабатываемые графовые структуры;</li>

<li><b>коллектива агентов</b>, работающих над <u>общей для них графодинамической памятью</u> и обменивающихся информацией <u>только</u> через эту память (в т. ч. и для координации своих действий).</li>

</ul>

<p>Графодинамическая память носит реконфигурируемый, структурно перестраиваемый характер, поскольку процесс обработки графовых структур в конечном счете сводится к генерации и удалению различных  элементов графовых структур, а также к генерации и удалению пар инцидентности между этими элементами. Другими словами, процесс обработки информации в графодинамической памяти  сводится не только к изменению состояния элементов памяти, но и к изменению конфигурации связей между ними.</p>

<p>
<b>Агенты</b>, работающие над общей графодинамической памятью, делятся на три вида:</p>

<ul>
<li>внутренние агенты, каждый из которых реагирует на определенного вида ситуации или события в графодинамической памяти и осуществляет изменение состояния графодинамической памяти, соответствующее своему функциональному назначению;</li>
<li>рецепторные агенты, каждый из которых реагирует на определенные события во внешней среде и осуществляет первичное отражение этих событий в графодинамической памяти;</li>
<li>эффекторные агенты, каждый из которых реагирует на определенного вида команды, формируемые внутренними агентами в графодинамической памяти, и осуществляет соответствующее изменение материального (физического) состояния интеллектуальной системы, которое определенным образом влияет на изменение её внешней среды.</li>
</ul>

<p>
Агенты могут работать параллельно, если одновременно возникают условия инициирования агентов. </p>

<p>
Асинхронность деятельности внутренних агентов заключается в том, что наличие условия инициирования агента ещё не означает начала его работы. То есть время реакции каждого внутреннего агента в известной мере субъективно и достаточно произвольно. В этом смысле указанные агенты обладают:</p>

<ul>
<li>свободой выбора момента начала реакции на условие инициирования;</li>
<li>свободой выбора последовательности обработки условий инициирования, если в текущий момент таких условий возникло несколько.</li>
</ul>

<p>
Для обеспечения эффективного взаимодействия агентов, работающих над общей графодинамической памятью, наряду с представляемой им свободой, необходима разработка таких правил их поведения, которые гарантируют безопасность и производительность каждого из них. В конечном счете, эти правила сводятся к двум положениям:</p>

<ul>
<li>позаботься о своей безопасности, точнее, об обеспечении безопасного выполнения своей задачи;</li>
<li>не навреди другим агентам (помни о том, что ты не один, не создавай для других "аварийных" ситуаций).</li>
</ul>

<p>
Для обеспечения безопасного выполнения своей задачи агент блокирует некоторые элементы графовой структуры, которая хранится в общей графодинамической памяти. Блокировка – это запрет, установленный заданным агентом и адресованный другим агентам, на выполнение тех или иных действий над заданным элементом хранимой графовой структуры. Таким образом, существует несколько видов таких блокировок. Приведем некоторые из них:</p>

<ul>
<li>запрет на удаление заданного элемента графовой структуры;</li>
<li>запрет на удаление <u>всех</u> элементов хранимой графовой структуры, инцидентных заданному (блокируемому) элементу;</li>
<li>запрет на удаление заданного вида элементов хранимой графовой структуры, которые связаны с блокируемым элементом выходящей из него (или входящей в него) парой инцидентности, принадлежащей заданному отношению инцидентности;</li>
<li>запрет на генерацию заданного вида элементов в хранимой графовой структуре, которые связаны с блокируемым элементом выходящей из него (или входящей в него) парой инцидентности, принадлежащей заданному отношению инцидентности.</li>
</ul>

<p>
Приведем некоторые правила поведения агента, работающего в коллективе агентов над общей графодинамической памятью:</p>

<ul>
<li>не нарушать блокировочные запреты, сформированные другими агентами;</li>
<li>самому заблокировать тот фрагмент обрабатываемой графовой структуры, целостность которого необходимо сохранить до завершения своей работы;</li>
<li>не "жадничать" – не блокировать больше, чем надо;</li>
<li>снимать свои блокировки как можно быстрее, как только в них отпадает необходимость (т. е. желательно это делать до завершения своей работы);</li>
<li>удалять сгенерированные для своей работы вспомогательные структуры (информационные "леса") как можно быстрее, как только в них отпадает необходимость (т. е. желательно убирать информационный "мусор" по мере возможности до завершения своей работы);</li>
<li>поиск фрагментов хранимой графовой структуры, являющихся условиями инициирования агента осуществлять поэтапно, начиная с поиска тех частей этих условий, которые реже появляются в памяти (это необходимо для того, чтобы скорее установить факт отсутствия условий инициирования).</li>
</ul>

<p>
В случае возникновения <b>конфликтов</b> между агентами используются внутренние агенты специального вида, реагирующие на возникновение таких конфликтов и обеспечивающие их разрешение (такие агенты будем называть метаагентами-судьями).</p>

<p>
Заметим, что для организации своей деятельности над графодинамической памятью каждый агент "опирается" на соответствующее ему семейство постоянно присутствующих в памяти (резидентных) элементов хранимой в памяти графовой структуры. Указанные элемениты будем называть ключевыми элементами агентов. Очевидно, что такие элементы соответствуют константам программ, описывающих поведение агентов.</p>

<p>
Сложность комплексного перехода на графодинамическую парадигму параллельной асинхронной обработки информации определяется исключительно психологическими обстоятельствами – это непривычно и, следовательно, боязно. Но накопленный человечеством опыт по созданию компьютерных систем и, в частности, интеллектуальных систем позволяет этот переход сделать достаточно быстро, так как многие проблемы, возникающие при реализации и применении графодинамических  моделей, имеют достаточно близкие аналоги в традиционных компьютерных системах, но многие из них могут быть решены значительно проще и элегантнее. Кроме того, в результате перехода к графодинамическим моделям "обнажается" целый ряд проблем, которые ранее просто были не видны. Эпицентром такого перехода является формализация семантики и разработка семантически совместимых языковых средств представления различных видов знаний.</p>

<p>
<b>4. Принцип ориентации на семантические (смысловые) модели представления и обработки знаний в графодинамических моделях</b></p>

<p>
В качестве формальной основы проектируемых интеллектуальных систем, в качестве основы абстрактных логико-семантических моделей интеллектуальных систем, предлагается использовать графодинамические модели специального вида – семантические модели представления и обработки знаний, в основе которых лежат <b>семантические сети</b> [Кузнецов, 1986], [Лозовский, 1984], [Плесневич, 1982], [Скороходько, 1989], [Шенк, 1980], [Sowa, 2008].</p>

<p>
Фактически, речь идет о создании формальных средств описания семантики различных видов знаний и формальных средств описания обработки знаний на семантическом уровне.</p>

<p>
<b>Семантическая сеть</b> – это графовая структура <i>G</i>, задаваемая пятеркой <i>< V, C, K, M, I ></i> и удовлетворяющая следующим требованиям, которые дополняют свойства множеств <i>V, C, K, M, I</i>, указанные в определении графовой структуры:</p>

<ul>
<li>каждая вершина <i>vj ∊ V</i> является знаком одного из объектов, описываемых семантической сетью;</li>
<li>каждая ключевая вершина <i>kj ∊ K</i> является знаком соответствующего класса элементов графовой структуры <i>G</i>;</li>
<li>каждая метка <i>mj ∊ M</i> также является знаком соответствующего класса элементов графовой структуры <i>G</i>;</li>
<li>каждая пара инцидентности, принадлежащая любому отношению инцидентности <i>ij ∊ I</i>, является парой принадлежности, связывающей знак некоторого множества элементов семантической сети с одним из этих элементов;</li>
<li>в семантической сети вершины <i>vj, vk ∊ V</i> могут быть инцидентны друг другу, но только в том случае, если по крайней мере одна из них (например, <i>vk</i>) является ключевой (<i>vk ∊ K</i>), а вторая является вершиной, принадлежащей множеству, обозначаемому ключевой вершиной vk (т.е. vj ∊ vk);</li>
<li>каждый элемент множества <i>I</i> (<i>ij ∊ I</i>) является знаком некоторого подмножества отношения принадлежности, задающего определенную роль, выполняемую соответствующими элементами семантической сети в рамках соответствующих множеств таких элементов. Указанные подмножества отношения принадлежности будем называть <b>ролевыми отношениями</b>;</li>
<li>каждый связующий элемент <i>cj ∊ С</i> является знаком некоторого фрагмента графовой структуры <i>G</i>, а точнее знаком некоторого подмножества множества всех элементов графовой структуры <i>G</i>;</li>
<li>среди элементов графовой структуры <i>G</i> нет пар, синонимичных друг другу знаков, т.е. знаков, обозначающих один и тот же объект (одну и ту же сущность) – либо один и тот же внешний описываемый объект, либо одно и то же множество элементов графовой структуры;</li>
<li>среди элементов графовой структуры <i>G</i> нет омонимичных знаков, которые в разных контекстах, в разных обстоятельствах могут обозначать разные сущности.</li>
</ul>

<p>
Следовательно, все (!) элементы (атомарные фрагменты)  семантической сети являются знаками различных сущностей (объектов). Такими сущностями могут быть всевозможные внешние описываемые объекты, а также различные множества, состоящие их элементов (атомарных фрагментов) этой же семантической сети.</p>

<p>
Таким образом, семантическая сеть – это абстрактная знаковая конструкция "рафинированного вида", в которой нет ничего кроме знаков и инцидентности этих знаков. В частности, в семантической сети отсутствуют элементарные незначащие фрагменты (символы), имена описываемых объектов, слова, из которых эти имена состоят, всевозможные разделители и ограничители, обеспечивающие структуризацию текста. В отличие от текстов традиционного вида, семантическая сеть имеет в общем случае нелинейный характер, поскольку каждый элемент семантической сети может быть инцидентен более чем двум другим элементам.</p>

<p>
Семантическую сеть можно трактовать как абстрактный текст, который является семантическим инвариантом соответствующего максимального множества семантически эквивалентных текстов, принадлежащих всевозможным языкам.</p>

<p>
На основе понятия семантической сети вводится понятие языка семантических сетей в заданном алфавите и с заданным набором ключевых узлов.</p>

<p>
Семантические сети как модели представления знаний известны давно. Но, в отличие от фреймовых, продукционных и логических моделей, для семантических сетей не были разработаны достаточно удобные и практически используемые языки представления знаний, достаточно удобные языки программирования, специально ориентированные на обработку семантических сетей. И, как следствие этого, не были созданы широко используемые комплексные технологии проектирования интеллектуальных систем, в основе которых лежат семантические сети. Причин тому много. Одна из них – это не совсем привычный, нетрадиционный характер таких моделей и возникший на этой основе миф о сложности их реализации. Если такие графодинамические семантические модели реализовывать "в лоб" и без ориентации на последующую аппаратную поддержку, то, конечно, это будет неэффективно. Но жизнь берет свое. И на фоне бурного развития микроэлектронных технологий подобного рода мифы выглядят все менее и менее убедительными. Более того, развитие Internet-технологий привело к необходимости формализации семантики информации, обрабатываемой в сети Internet, что вызывало бурное развитие целого направления – Semantic Web.</p>

<p>
Чем же хороши семантические сети и в чем достоинство семантических моделей обработки информации:</p>

<ul>
<li>Представление знаний в виде семантических сетей позволяет существенно упростить процедуру интеграции знаний и свести эту процедуру к выявлению и склеиванию синонимичных элементов интегрируемых семантических сетей;</li>
<li>Специфика обработки баз знаний заключается в том, что порождаемые (генерируемые) новые фрагменты знаний необходимо не просто построить, но и погрузить, интегрировать в текущее состояние базы знаний, т.к. в этих порождаемых фрагментах знаний могут появиться знаки, синонимичные тем, которые уже присутствуют в текущем состоянии базы знаний. Таким образом, процедура интеграции порождаемых фрагментов обрабатываемой базы знаний является процедурой, постоянно  используемой в ходе обработки знаний. Следовательно, представление знаний в виде семантических сетей, благодаря упрощению процедуры интеграции знаний, позволяет упростить не только ввод новых знаний из вне, но и интеграцию в состав текущего состояния базы знаний новых знаний, порождаемых в ходе решения задач;</li>
<li>База знаний интеллектуальной системы, представленная в виде корректно построенной семантической сети, полностью исключает дублирование информации в рамках такой базы знаний – каждая информация, представленная соответствующим фрагментом семантической сети, должна находиться в рамках этой семантической сети там и только там, где она должна находиться, и нигде больше;</li>
<li>Представление знаний в виде семантических сетей позволяет существенно упростить процедуру ассоциативного доступа к различным видам фрагментов хранимой базы знаний, а также существенно расширить типологию запросов (вопросов) к базе знаний;</li>
<li>Семантические модели обработки знаний не просто хорошо приспособлены к поддержке параллельной асинхронной обработки информации, но и обеспечивают обмен информацией через общую графодинамическую память между различными параллельно (одновременно) протекающими (выполняемыми) процессами, что может существенно ускорить каждый из этих процессов. Примером такого взаимодействия параллельно протекающих процессов является одновременная реализация разных стратегий и тактик, направленных на поиск пути решения заданной нетривиальной задачи;</li>
<li>С помощью семантических моделей представления и обработки знаний можно проинтерпретировать все известные виды моделей представления обработки знаний (фреймовые, продукционные, логические), а также все известные модели решения задач различного вида и все известные модели рассуждений. Это дает возможность рассматривать перечисленные модели не как альтернативные, а как дополняющие друг друга модели, которые могут сосуществовать в разных сочетаниях в разных интеллектуальных системах.
</li>
</ul>

<p>
Семантическая модель обработки знаний представляет собой абстрактную многоагентную систему, состоящую из <b>абстрактной семантической памяти</b> в которой хранятся семантические сети, и из множества агентов, ориентированных на обработку семантических сетей, хранимых в указанной семантической памяти.</p>

<p>
Семантическую память можно трактовать как абстрактную семантическую модель памяти интеллектуальной системы.</p>

<p>
Семейство абстрактных агентов, работающих над семантической памятью вместе с этой семантической памятью можно трактовать как <b>семантическую модель решения задач</b>, используемую в соответствующей интеллекту-альной системе, или как операционную семантику этой интеллектуальной системы. Подчеркнем, что семантическую модель обработки информации можно построить для любой компьютерной системы (как для интеллектуальной системы, так и для компьютерной системы традиционного вида), обеспечивая, тем самым, семантическую совместимость (на абстрактном уровне) не только интеллектуальных систем, но и компьютерных систем любого уровня интеллектуальности.</p>

<p>
Всю семантическую сеть (максимальную семантическую сеть), хранимую в семантической памяти абстрактной логико-семантической модели интеллектуальной системы, будем называть <b><i>абстрактной семантической моделью базы знаний</i></b> этой интеллектуальной системы.</p>

<p>
<b>База знаний</b> должна содержать в себе всю информацию, необходимую агентам, работающим над семантической памятью, для организации коллективной деятельности по решению задач, с которыми должна справляться интеллектуальная система (сюда, в том числе входит и описание блокировок, задаваемых разными процессами в семантической памяти).</p>

<p>
<b><i>Семантическая модель базы знаний интеллектуальной системы</i></b> – это, образно говоря, формальная трактовка "семантического пространства" в котором "живет" эта интеллектуальная система, а, точнее, такого фрагмента указанного "семантического пространства", который в текущий момент указанной интеллектуальной системе известен.</p>

<p>
В целом <b><i>логико-семантическая модель интеллектуальной системы</i></b> включает в себя:</p>

<ul>
<li>семантическую модель базы знаний этой интеллектуальной системы;</li>
<li>семантическую машину обработки знаний этой интеллектуальной системы, которая, в свою очередь, состоит из:
</li>
	<ul>
	<li>семантической памяти;</li>
	<li>коллектива агентов над семантической памятью.</li>
	</ul>
</ul>

<p><b>
5. Принцип унификации абстрактного семантического (смыслового) представления различного вида знаний</b></p>

<p>
Предлагается определить структуру унифицированных семантических сетей, обеспечивающих представление и интеграцию самых различных видов знаний.</p>

<p>
Это предполагает разработку соответствующего стандарта, выделяющего из всего многообразия абстрактных языков семантических сетей определенный базовый универсальный язык семантических сетей, который мы назвали <b><i>SC-кодом</i></b> (Semantic Computer code).</p>

<p>
Для того, чтобы перейти от семантических сетей произвольного вида к текстам <b><i>SC-кода</i></b> уточним направления такого перехода, т.е. задаваемые нами критерии качества разрабатываемого языка семантических сетей (<b><i>SC-кода</i></b>). К таким критериям мы отнесем:</p>

<ul type="1">
<li> Переход от семантических сетей, имеющий унарные и многокомпонентные (многоместные) связки, к семантическим сетям, имеющим только бинарные связки. Такие сети будем называть бинарными семантическими сетями [Плесневич, 2008], [Карабеков и др., 2008];</li>
<li> Минимизация алфавита, т.е. минимизация числа меток, используемых в семантических сетях;</li>
<li> Универсальность разрабатываемого языка, т.е. возможность представления любых знаний в виде текстов этого языка.
</li>
</ul>

<p>
Семантическую сеть <i>Gb</i> задаваемую пятеркой, <i>< Vb, Cb, Kb, Mb, Ib ></i> будем называть <b>бинарной семантической сетью</b> в том и только в том случае, если:</p>

<ul>
<li>все связующие элементы, входящие во множество <i>Cb</i>, являются бинарными связками, каждая из которых имеет только два компонента, которыми могут быть элементы множества <i>Vb</i>, элементы множества <i>Cb</i> и элементы множества Kb;</li>
<li><i>Ib={i1, i2}</i>, где <i>i1</i> – бинарное ориентированное отношение инцидентности, связывающее бинарную связку с её компонентом; <i>i2</i> – бинарное ориентированное отношение инцидентности, связывающее бинарную ориентированную связку с ее вторым компонентом. Очевидно, что <i>i1 &sub; i2</i>.
</li>
</ul>

<p>
Для любой семантической сети <i>G</i>, задаваемой пятеркой <i>< V, С, К, М, I ></i>, можно построить семантически эквивалентную ей бинарную семантическую <i>Gb</i>, задаваемую пятеркой <i>< Vb, Cb,  Kb, Mb,  Ib ></i> следующим образом:</p>

<ul>
<li> во множество <i>Vb</i> включаются все вершины (<i>V</i>) семантической сети <i>G</i> и все небинарные связующие элементы (<i>Сn</i>) семантической сети <i>G</i> (<i>Сп &sub; G</i>);</li>
<li><i>Ib = {i1, i2}</i> – это отношения инцидентности связывающие бинарные связки (в том числе из множества <i>С</i>) с их компонентами;</li>
<li><i>Мb = ( М &cup; { re } )</i>. Если в алфавит <i>М</i> не входила метка отношения принадлежности (re), то в алфавит Мb она дополнительно вводится;</li>
<li><i>b = К &cup; (I \ ( Ib &cup; { re } ) )</i>. Т.е. знаки отношений инцидентности, связывающих (в рамках <i>G</i>) небинарные связующие элементы с их компонентами, становятся в рамках <i>Gb</i> ключевыми узлами;</li>
<li>во множество <i>Сb</i> включаются (1) все бинарные связки семантической сети <i>G</i>, (2) все ориентированные пары отношения принадлежности (<i>re</i>), связывающие ключевые вершины семантической сети <i>G</i> с инцидентными им элементами семантической сети, (3) все ориентированные пары всех отношений инцидентности ( <i>I</i> ), связывающих небинарные связующие элементы (из множества <i>С</i>) с их компонентами, (4) все пары принадлежности, явно связывающие ключевые узлы семантической сети <i>Gb</i>, соответствующие различным отношениям инцидентности ( <i>I</i> ) семантической сети <i>G</i>, с парами принадлежности которые явно связывают небинарные связующие элементы с их компонентами, выполняющими в рамках этих связующих элементов роли, обозначаемые указанными отношениями инцидентности.<li>
</ul>
<p>
Нетрудно заметить, что приведение семантической сети к бинарному виду приводит также к минимизации числа отношений инцидентности.</p>

<p>
Нетрудно также заметить, что все пары инцидентности, связывающие небинарные связующие элементы семантической сети <i>G</i> с их компонентами, в бинарной семантической сети <i>Сb</i> "превращаются" в бинарные ориентированные связки, которые принадлежат отношению принадлежности и которые, следовательно, должны быть помечены меткой <i>rе</i> (<i>rе &isin; Мb</i>), являющейся знаком отношения принадлежности.</p>

<p>
Таким образом, каждый небинарный связующий элемент семантической сети <i>G</i> в семантической сети <i>Gb</i> трактуется как множество связываемых им элементов семантической сети, связь которого с его элементами представляется явно – не в виде пар инцидентности, а в виде дополнительно вводимых связок принадлежности. Эти связки принадлежности, в свою очередь, могут быть вторыми компонентами других связок принадлежности, связывающих указанные связки с ключевыми узлами, обозначающими различные роли компонентов небинарных связующих элементов исходной семантической сети.</p>

<p>
Бинарные связки легко изображать графически (в виде линий, каждая из которых соединяет графические изображения двух связываемых элементов семантической сети). Использование только бинарных связок существенно упрощает машинное кодирование семантических сетей и, в частности, упрощает разработку специальной памяти для хранения семантических сетей.</p>

<p>
В основе <b>минимизации алфавита</b> элементов лежит следующее свойство семантических сетей. Метки, входящие в состав алфавита элементов семантической сети, и ключевые узлы этой семантической сети семантически эквивалентны в том смысле, что просто являются синтаксически различными способами выделения (задания) различных классов элементов семантической сети. При этом заметим, что в отличие от алфавита символов линейного текста, все элементы алфавита (все метки) семантической сети, как и все ее ключевые узлы, имеют семантическую интерпретацию на описываемой предметной области. Таким образом, метки элементов семантической сети без какого-либо изменения семантики этой семантической сети можно "превращать" (преобразовывать) в ее ключевые узлы. При этом семантическая интерпретация каждого такого ключевого узла будет совпадать с семантикой соответствующей преобразованной метки.</p>

<p>
Если мы имеем дело с корректно (правильно) построенной семантической сетью и записанной в некотором языке семантических сетей, то перевод этой семантической сети на любой другой язык семантических сетей не требует больших усилий, т.к. имеет место большое сходство синтаксического и семантического устройства всех языков семантических сетей. Фактически эти языки отличаются своими алфавитами, элементы которых, как было показано выше, легко преобразуются в ключевые узлы семантических сетей.</p>

<p>
Итак, число меток семантической сети можно уменьшать ценой расширения множества её ключевых узлов. Вопрос в том, до какого предела это можно делать и как выглядит минимальный алфавит универсального языка семантических сетей. Универсальным языком семантических сетей будем называть такое множество семантических сетей, элементами которых являются семантические сети, представляющие любую информацию о любой описываемой предметной области.</p>

<p>
Из сказанного ранее следует, это в состав минимального алфавита универсального языка семантических сетей, по крайней мере, должна входить метка re, обозначающая <b><i>отношение принадлежности</i></b>. Без этой метки невозможно описать связи ключевых узлов семантической сети с элементами обозначаемых ими классов, а также невозможно осуществить переход к бинарным семантическим сетям.</p>

<p>
Текст, принадлежащий SC-коду, т.е. <b><i>sc-текст</i></b> (sc-структура, sc-конструкция) является семантической сетью частного вида, имеющей следующие особенности:</p>

<ul>
<li>все связки sc-текстов являются бинарными связками, которые будем называть <b><i>sc-коннекторами</i></b>. Неориентированные sc-коннекторы будем называть <b><i>sc-ребрами</i></b>, ориентированные – <b><i>sc-дугами</i></b>.</li>
<li>множество меток элементов sc-текстов (алфавит sc-элементов, алфавит SC-кода) включает в себя:
	<ul>
	<li><b><i>метку sc-узлов (вершин sc-текстов);</i></b></li>
	<li><b><i>метку sc-ребер;</i></b></li>
	<li><b><i>метку sc-дуг общего вида;</i></b></li>
	<li><b><i>метку sc-дуг принадлежности;</i></b></li>
	<li><b><i>метку sc-дуг основного вида.</i></b></li>
	</ul>
</li>
<li>множество отношений инцидентности элементов sc-текстов состоит из двух следующих отношений:
	<ul>
	<li><i>быть <b>компонентом sc-коннектора</b></i> (sc-ребра или sc-дуги);</li>
	<li><i>быть <b>вторым компонентом sc-дуги;</b></i></li>
	</ul>
</li>
<li>множество ключевых узлов SC-кода (ключевых узлов sc-текстов) вместе с метками sc-элементов задает базовую семантическую типологию sc-элементов, т.е. базовую онтологию SC-кода.</li>
</ul>

<p>
К числу ключевых узлов SC-кода, определяющих разбиение множества sc-элементов по признаку <b>константности</b>, относятся:</p>

<ul>
<li>ключевой sc-узел, обозначающий множество всевозможных константных sc-элементов (<b><i>sc-констант</i></b>). Каждая sc-константа является обозначением некоторого конкретного фиксированного объекта;</li>
<li>ключевой sc-узел, обозначающий множество всевозможных переменных sc-элементов (<b><i>sc-переменных</i></b>), каждая из которых обозначает некоторый произвольный, нефиксированный объект из некоторого дополнительно уточняемого множества объектов. Используются sc-переменные в логических формулах (в т.ч. в высказываниях), в программах (в обобщенных описаниях способов решения различных классов задач), в формулировках вопросов.</li>
</ul>

<p>
К числу ключевых узлов SC-кода, определяющих разбиение множества sc-элементов по <b>структурному признаку</b>, относятся:</p>

<ul>
<li>ключевой sc-узел, обозначающий множество всевозможных <b><i>sc-коннекторов</i></b>, т.е. атомарных связок sc-элементов. Более детальное разбиение множества sc-коннекторов по структурному признаку осуществляется с помощью меток sc-элементов (на <b><i>sc-ребра</i></b>, <b><i>sc-дуги общего вида</i></b>, <b><i>sc-дуги принадлежности</i></b>, <b><i>sc-дуги основного вида</i></b>);</li>
<li>ключевой sc-узел, обозначающий множество всевозможных sc-узлов, каждый из которых обозначает некоторое связующее множество sc-элементов. Указанные sc-элементы будем называть <b><i>связующими sc-узлами</i></b>. К числу ключевых узлов SC-кода, определяющих более детальную структурную типологию связующих sc-узлов, относятся:
	<ul>
	<li>ключевой sc-узел, обозначающий множество всевозможных sc-узлов, каждый из которых обозначает некоторую неатомарную связь между sc-элементами, т.е. связь, не являющуюся sc-коннектором. Такие sc-узлы будем называть <b><i>неатомарными sc-связками</i></b>. Более детальная структурная типология неатомарных sc-связок задается такими ключевыми узлами SC-кода, как быть <b><i>унарной sc-связкой</i></b>, быть <b><i>бинарной неатомарной sc-связкой</i></b>, быть <b><i>многокомпонентной sc-связкой</i></b>, быть <b><i>ориентированной неатомарной sc-связкой</i></b>, быть <b><i>неориентированной неатомарной sc-связкой</i></b>;</li>
	<li>ключевой sc-узел, обозначающий множество всевозможных sc-узлов, каждый из которых обозначает некоторую структуру из sc-элементов. Такие структуры будем называть обозначениями sc-структур или просто <b><i>sc-структурами</i></b>.</li>
	</ul>
	</li>
<li>ключевой sc-узел, обозначающий множество всевозможных sc-узлов, каждый из которых обозначает некоторый класс sc-элементов. Такие sc-узлы будем называть обозначениями sc-понятий или, просто, <b><i>sc-понятиями</i></b>. Более детальная структурная типология sc-понятий задается следующими ключевыми узлами SC-кода: быть <b><i>отношением</i></b> (классом однотипных связок), быть <b><i>бинарным отношением</i></b>, быть <b><i>унарным отношением</i></b>, быть <b><i>многоместным отношением</i></b>, быть <b><i>ориентированным отношением</i></b>, быть <b><i>неориентированным отношением</i></b>, быть <b><i>ролевым отношением</i></b> (т.е. отношением, которое является подмножеством отношения принадлежности), быть <b><i>классом структур</i></b>, быть <b><i>классом терминальных sc-узлов</i></b> (первичных sc-узлов, которые не являются обозначениями множеств sc-элементов).</li>
<li>ключевой sc-узел, обозначающий множество всевозможных sc-узлов, каждый из которых обозначает некоторый объект, который не является множеством sc-элементов. Такие sc-узлы будем называть <b><i>терминальными sc-узлами</i></b> (первичными sc-узлами). Более детальная структурная типология терминальных sc-узлов задается следующими ключевыми узлами sc-кода:
	<ul>
	<li>быть <b><i>предметным sc-узлом</i></b>, каждый из которых обозначает некоторый реальный (материальный, физический) или вымышленный внешний объект некоторой предметной области;</li>
	<li>быть <b><i>sc-ссылкой</i></b>, каждая из которых обозначает либо определенный файл, который можно просматривать или в котором закодирована в определенном формате некоторая внешняя, инородная для SC-кода информационная конструкция, либо некоторую компьютерную систему, с которой можно взаимодействовать;</li>
	<li>быть <b><i>терминальным элементом шкалы или шаблона</i></b> (это sc-элементы, для которых трудно установить обозначаемые ими объекты, поскольку эти sc-узлы просто являются терминальными элементами каких-либо шкал, шаблонов, типовых структур, с которыми устанавливаются соответствия, с которыми сравниваются, сопоставляются различные объекты и структуры).</li>
	</ul>
</li>
</ul>

<p>
К числу ключевых узлов SC-кода, уточняющих семантику sc-дуг принадлежности, относятся:
</p>
<ul>
<li>ключевые узлы SC-кода, определяющие разбиение множества sc-дуг принадлежности по признаку <b>позитивности</b>:
	<ul>
	<li>быть <b><i>sc-дугой позитивной принадлежности</i></b>;</li>
	<li>быть <b><i>sc-дугой негативной принадлежности</i></b>;</li>
	<li>быть <b><i>sc-дугой нечеткой принадлежности</i></b> (т.е. sc-дугой, позитивность или негативность которой в текущий момент не установлена);</li>
	</ul>
</li>
<li>ключевые узлы SC-кода, определяющие разбиение множества sc-дуг принадлежности по признаку <b>стационарности</b>:
	<ul>
	<li>быть <b><i>sc-дугой стационарной принадлежности</i></b>, семантический тип которой является постоянным, не изменяющимся во времени;</li>
	<li>быть <b><i>sc-дугой нестационарной принадлежности</i></b>, семантический тип которой изменяется во времени;</li>
	</ul>
</li>
</ul>

<p>
Заметим, что <b><i>sc-дуги основного вида</i></b>, которые выделяются с помощью соответствующей метки, семантически трактуются <b><i>как sc-дуги позитивной стационарной принадлежности</i></b>. </p>

<p>
Перечислим основные <u>особенности</u> и <u>достоинства</u> SC-кода.</p>

<p>
Унифицированные семантические сети (sc-тексты) – это абстрактная семантическая модель знаний, являющаяся <u>инвариантом</u> различных способов представления и кодирования этих же знаний (в том числе и самих семантических сетей). Наличие такого инварианта необходимо для решения проблемы интеграции самых различных видов знаний. На основе унифицированных семантических сетей можно строить семантические модели различных компьютерных систем и решить проблему интеграции таких систем.</p>

<p>
SС-код является <u>абстрактным</u> языком в том смысле, что способ изображения (материализации) его текстов не уточняется. Следовательно, можно разрабатывать различные графические уточнения SС-кода (например, SСg-код), различные варианты изображения sс-текстов в виде строк символов (например, SСs-код), различные варианты машинного представления sc-конструкций в адресной памяти традиционных компьютеров, а также в специальной структурно перестраиваемой ассоциативной памяти будущих компьютеров, ориентированных на обработку баз знаний.</p>

<p>
Все sc-элементы, кроме терминальных sc-узлов, являются обозначениями множеств, состоящих из sc-элементов (множеств sc-элементов). Такие sc-элементы будем называть <b><i>вторичными sc-элементами</i></b>. Из этого следует то, что SC-код имеет базовую теоретико-множественную семантическую интерпретацию.</p>

<p>
SС-код представляет собой достаточно простой компьютерный код семантических сетей, который является не "инородным" представлением семантических сетей, а их представлением тоже в виде семантических сетей, но максимально простого вида – с минимальным алфавитом и с бинарными связками.</p>

<p>
SС-код ориентирован на представление информации в компьютерной памяти и может рассматриваться как основа модели структурно перестраиваемой ассоциативной памяти будущих компьютеров, ориентированных на обработку семантических сетей. Т.е. SС-код можно рассматривать как универсальную основу машинного кодирования знаний в памяти будущих компьютеров, ориентированных на обработку семантических сетей. В такой памяти биты и байты "уступят место" sс-дугам, sс-ребрам и sс-узлам.</p>

<p>
На базе SC-кода можно создавать целое семейство совместимых специализированных языков, ориентированных на представление самых разных видов знаний (логических формул и высказываний, программ, вопросов, поведенческих целей, различных видов моделей динамических систем и т.п.), таким образом, чтобы тексты всех этих специализированных языков полностью соответствовали SC-коду (т.е. были sc-текстами). Такие специализированные языки, общим носителем которых является SC-код, будем называть <b><i>sc-языками</i></b>. Каждый sc-язык определяется своим расширением множества ключевых узлов SC-кода.</p>

<p>
SС-код представляет собой ядро <b>универсального открытого языка семантических сетей</b>, являющегося результатом интеграции всевозможных языков семантических сетей, построенных на основе SС-кода, и задаваемого:</p>

<ul>
<li>фиксированным алфавитом (алфавитом SС-кода);</li>
<li>постоянно расширяемым (открытым) семейством ключевых узлов, в состав которого входят все ключевые узлы всех интегрируемых языков.</li>
</ul>

<p>
SС-код представляет собой <b>единство языка и метаязыка</b>. Так, например, в виде sс-конструкций можно описать синтаксис, семантику и онтологию SС-кода. С формальной точки зрения SС-код можно трактовать как метаязык базовой семантической спецификации sс-элементов с помощью специального набора ключевых узлов SС-кода.</p>

<p>
Единство языка и метаязыка в SС-коде проявляется в том числе и на самом низком уровне – на уровне sc-дуг принадлежности <i>< si, ei ></i>, в которых сам sс-элемент <i>ei</i>, а не обозначаемый им объект, является элементом множества, обозначаемого sс-узлом <i>si</i>.</p>

<p>
SС-код позволяет описать структуру любой информационной конструкции, не принадлежащей SС-коду, на любом уровне (на любом этапе синтаксического и семантического анализа). В частности, первичную синтаксическую структуру любой информационной конструкции можно представить в виде изоморфной sс-конструкции. Следовательно, SС-код может быть использован в качестве метаязыка для описания любого внешнего языка, т.е. языка, тексты которого не являются sс-конструкциями.</p>

<p>
SС-код хорошо приспособлен к использованию в условиях так называемых <b>не-факторов</b> - нестационарности, неточности, противоречивости, неактуальности знаний, а также неполноты знаний (нечеткости, несформированности множеств, несформированности внешних информационных конструкций) [Нариньяни, 1994].</p>

<p>
Информационные конструкции SС-кода (sс-конструкции) легко <b>визуализируются</b>.</p>

<p>
<b>6. Принцип унификации структуризации баз знаний</b></p>

<p>
Предлагается трактовать семантическую структуру <b>базы знаний</b> интеллектуальной системы как отражение иерархической системы взаимосвязанных друг с другом <b>предметных областей</b>, представляемых в базе знаний. Это предполагает</p>

<ul type="1">
<li>уточнение понятия предметной области;</li>
<li>разработку языковых средств описания структуры предметных областей с помощью унифицированных семантических сетей;</li>
<li>разработку языковых средств описания типологии предметных областей и различных видов связей между ними.</li>
</ul>

<p>
Структуризация базы знаний, выделение в ней различных связанных между собой подструктур необходимы по целому ряду причин. В частности, это необходимо для дидактических целей (человеку усваивающему некоторые знания, желательно иметь, своего рода оглавление или "карту" этих знаний, что позволяет планировать их усвоение и рассматривать их с различной степенью детализации), а также для организации распределения работ по проектированию баз знаний (когда разным исполнителям поручается разработка разных фрагментов базы знаний, имеющих достаточно четкие границы).</p>

<p>
Таким образом, база знаний рассматривается нами как система взаимосвязанных между собой интегрируемых структур, которые будем называть <b>фрагментами базы знаний</b>. Связи между фрагментами базы знаний могут быть самыми различными. Каждый фрагмент и вся база знаний в целом может иметь несколько вариантов декомпозиции на подфрагменты (частные фрагменты).</p>

<p>
По стурктурно-семантическому принципу можно выделить следующие типы фрагментов баз знаний:</p>

<ul>
<li>база фактов некоторой предметной области, которую, сокращенно, будем называть просто <b>предметной областью</b> и которая представляет собой результат интеграции всех известных в текущий момент фактографических высказываний, являющихся истинными для указанной предметной области;</li>
<li><b>иерархическая система нескольких предметных областей</b>, которые нецелесообразно объединять (интегрировать) в <u>одну</u> предметную область, так как в результате этого получается "сборная солянка";</li>
<li><b>семантическая окрестность заданного объекта</b>;</li>
<li><b>связная семантическая окрестность конечного множества заданных объектов</b>, представляющая сравнение (сравнительный анализ) и связи объектов из заданного конечного множества, т. е. описывающая сходства (аналогии), отличия заданных объектов, а также "близкие" связи между ними.</li></ul>

<p>
При структуризации базы знаний некоторым её фрагментам приписывается статус <b>разделов базы знаний</b>, которые именуются, нумеруются и входят в состав (оглавление) базы знаний.</p>

<p>
Рассмотрим формальное уточнение понятия <b>предметной области</b> с помощью SC-кода. Если в рамках <b>sc-модели базы знаний</b> явно вводится некоторая предметная область, то она трактуется как некоторая sc-структура, для которой в базе знаний явно вводится обозначающий её sc-узел, который, в свою очередь, связывается входящей в него sc-дугой основного вида с sc-узлом, обозначающим класс sc-структур, являющихся предметными областями. После этого в указанной sc-структуре необходимо явно задать роли некоторых узлов, входящих в состав этой sc-структуры. К числу таких ролей относятся:</p>

<ul>
<li>быть <b><i>максимальным классом исследуемых объектов</i></b>, т. е. множеством всех исследуемых объектов и только их. В каждой предметной области существует только один ключевой узел, выполняющий такую роль;</li>
<li>быть <b><i>классом исследуемых объектов</i></b>. Каждая предметная область может иметь любое число таких классов;</li>
<li>быть <b><i>классом вторичных объектов</i></b>, построенных на основе исследуемых;</li>
<li>быть <b><i>классом вспомогательных объектов</i></b>, через связи с которыми описываются некоторые характеристики исследуемых объектов;</li>
<li>быть <b><i>отношением, каждая связка которого связывает только исследуемые объекты</i></b> или вторичные объекты, построенные на основе исследуемых;</li>
<li>быть <b><i>отношением, каждая связка которого связывает исследуемые объекты со вспомогательными</i></b>.</li></ul>

<p>
Такое явное указание ролей ключевых элементов предметных областей есть не что иное, как их семантическая спецификация, уточняющая то, <u>какие объекты</u> описываются (исследуются) в данной предметной области, и о <u>каких характеристиках</u>, связях исследуемых объектов в данной предметной области идет речь.</p>

<p>
Можно говорить о достаточно богатой типологии предметных областей. В частности, можно выделить следующие классы предметных областей:</p>

<ul>
<li>предметная область, описывающая теоретико-множественные характеристики и связи заданного семейства объектов. Такие предметные области, в частности, могут быть онтологиями других предметных областей;</li>
<li>терминологическая сеть заданного фрагмента базы знаний;</li>
<li>текст формальной теории, описывающей свойства и закономерности заданной предметной области. Классами объектов исследования такой предметной метаобласти являются: (1) класс логических формул и, в частности, высказываний интерпретируемых на заданной  предметной области, (2) класс элементов заданной предметной области, используемых в качестве констант в указанных логических формулах, (3) класс переменных, используемых в указанных логических формулах и возможными значениями которых являются соответствующие элементы заданной предметной области;</li>
<li>логическая система понятий, описываемых в заданной формальной теории. Эта предметная метаобласть выделяет класс понятий, не определяемых в заданной формальной теории, и связывает каждое определяемое понятие с теми понятиями, на основе которых оно определяется;</li>
<li>логическая система утверждений заданной формальной теории. Эта предметная метаобласть выделяет класс аксиом для заданной формальной теории, каждой теореме ставит в соответствие одно из её доказательств (основное доказательство) и связывает каждую теорему со всеми теми утверждениями и определениями, которые используются в основном доказательстве этой теоремы;</li>
<li>логическая система фрагментов баз знаний, связывающая каждый фрагмент базы знаний с теми фрагментами, в которых (1) даются определения понятий, используемых в заданном  фрагменте и (2) вводятся и доказываются используемые утверждения. На основании такой логической системы строятся различные варианты последовательности изучения (прочтения) разделов баз знаний.</li></ul>

<p>
Заметим, что некоторым из перечисленных классов предметных областей может соответствовать одинаковый (унифицированный, фиксируемый) набор используемых в них ключевых понятий. Унификация (стандартизация) таких наборов понятий является важнейшим средством более глубокой семантической совместимости (интегрируемости) различных фрагментов базы знаний. Результатом такой унификации фактически является разработка средств SC-кода, ориентированных на представление предметных областей соответствующего класса. Такие языковые средства будем называть специализированным sc-языком.</p>

<p>
К числу таких специализированных sc-языков можно отнести:</p>

<ul>
<li><b>Теоретико-множественный sc-язык</b>, обеспечивающий описание теоретико-множественных характеристик и связей заданного семейства объектов. С помощью такого языка, в частности, могут быть представлены предметные области, являющиеся теоретико-множественными онтологиями других предметных областей;</li>
<li><b>Терминологический sc-язык</b>, обеспечивающий построение терминологических сетей;</li>
<li><b>Логический sc-язык</b>, обеспечивающий построение sc-текстов формальных теорий.</li></ul>

<p>
Таким образом, <b>SC-код</b> является ядром целого семейства самых различных <b>sc-языков</b>, ориентированных на описание различных классов предметных областей, в каждый из которых входят предметные области с разными множествами исследуемых объектов, но с одинаковыми предметами исследования.</p>

<p>
Каждому такому специализированному sc-языку ставится в соответствие <b>множество ключевых узлов</b>, обозначающих различные классы исследуемых объектов, различные отношения и алгебраические операции, заданные на множестве исследуемых объектов.</p>
<p>SC-язык, являющийся объединением всевозможных специализированных sc-языков будем называть <b>языком SCK (Semantic Code Knowledge)</b>. Этот язык рассматривается нами как интегрированный язык представления знаний. Язык SCK является открытым (расширяемым) языком, поскольку его всегда можно пополнить новым sc-языком, описывающим структуры нового вида предметных областей.</p>

<p>
Построение <b>семантической структуры базы знаний</b> интеллектуальной системы требует не только явного представления спецификаций каждой описываемой предметной области в виде sc-текста, но и явного описания всевозможных связей между этими предметными областями.</p>

<p>
Переходя к рассмотрению отношений, заданных на множестве предметных областей, мы фактически переходим к некоторой предметной <u>метаобласти</u>, объектами исследования которой являются всевозможные предметные области (в том числе и сама эта предметная метаобласть).</p>

<p>
Обобщая понятия гомоморфизма и изоморфизма алгебраических систем, можно говорить о гомоморфизме и изоморфизме предметных областей, что дает хорошую основу для выявления глубоких нетривиальных аналогий между предметными областями.</p>

<p>
Различные предметные области могут пересекаться. То есть элементы одной предметной области могут быть также и элементами другой предметной области. При этом возможны самые различные варианты такого пересечения. Это может быть строгое пересечение, строгое включение. Общие элементы пересекающихся предметных областей могут в рамках этих областей выполнять как одинаковые, так и разные роли. Так, например, первичные элементы одной предметной области могут входить в состав другой предметной области в качестве вторичных элементов, в качестве ключевых элементов. Объекты исследования одной предметной области могут входить в состав другой предметной области и в качестве вспомогательных элементов.</p>

<p>
В качестве примеров отношений, заданных на множестве предметных областей рассмотрим несколько вариантов выделения частных предметных областей:</p>

<ul>
<li>выделение частной предметной области, на основе выделения подмножества из максимального класса исследуемых объектов. Таким способом из предметной области геометрии, объектами исследования которой являются геометрические точки, фигуры и семейства фигур, можно выделить (1) предметную область планиметрии, изучающую планарные фигуры и планарные семейства фигур (т. е. семейства фигур, лежащих в одной плоскости) и (2) предметную область стереометрии, которая изучает непланарные фигуры и непланарные семейства фигур, которые могут состоять как из непланарных, так и из планарных фигур;</li>
<li>выделение частной предметной области, на основе выделения подмножества из семейства классов исследуемых объектов. Таким способом из предметной области, изучающей треугольники, можно выделить (1) предметную область, изучающую остроугольные, тупоугольные и прямоугольные треугольники, а также (2) предметную область, изучающую равносторонние, разносторонние и равнобедренные треугольники;</li>
<li>выделение частной предметной области, на основе выделения подмножества из семейства отношений, заданных на исследуемых объектах. Таким способом из геометрической предметной области можно выделить (1) предметную область, объектами исследования которой являются геометрические фигуры, а предметом исследования – их числовые характеристики и (2) предметную область, объектами исследования которой являются геометрические фигуры, а предметом исследования – различные виды их конгруэнтности (движений).</li></ul>

<p>
Предметная область позволяет рассматривать исследуемые объекты на разных уровнях детализации. Детализацию рассмотрения исследуемых объектов можно осуществлять как в рамках исходной (заданной) предметной области, расширяя эту предметную область в соответствующих направлениях, а можно переходить к системе самостоятельных, но связанных между собой предметных областей.</p>

<p>
Первым и важнейшим этапом проектирования базы знаний является уточнение структуры описываемой предметной области или нескольких взаимосвязанных предметных областей. Уточнение такой структуры – это, прежде всего, уточнение класса исследуемых объектов, уточнение предмета исследования, уточнение всего семейства ключевых узлов семантической сети, представляющей предметную область. При этом для заданного класса исследуемых объектов и заданного предмета исследования можно построить более качественную и менее качественную предметную область.</p>

<p>
Рассмотрим еще один тип фрагментов баз знаний – <b>семантические окрестности</b>. В общем случае семантическая окрестность заданного объекта – это описание некоторых, числовых характеристик, свойств и связей заданного объекта. Частными видами семантических окрестностей являются:</p>

<ul>
<li>описание характеристик, свойств или связей заданного объекта, <u>однозначно (!)</u> определяющих (устанавливающих) заданный объект (для понятий – это определение или любое другое высказывание определяющего типа);</li>
<li>полная (интегрированная) семантическая окрестность заданного объекта, содержащая все известные в <u>текущий момент</u> сведения об этом объекте в рамках заданного раздела базы знаний или в рамках всего текущего состояния базы знаний;</li>
<li>описание числовых характеристик (параметров, признаков) заданного объекта;</li>
<li>описание свойств заданного объекта (это те истинные нефактографические высказывания, в которых знак этого объекта используется в качестве константы);</li>
<li>описание теоретико-множественных связей заданного объекта с другими объектами;</li>
<li>описание разноязычных терминов, иероглифов, пиктограмм, используемых для внешней идентификации заданного объекта (в т. ч. и описание происхождения этих идентификаторов);</li>
<li>перечень отношений, соответствующих заданному объекту (отношений, в области определения которых заданный объект входит в качестве элемента; отношений, в области определения которых заданный объект входит в качестве подмножества; отношений, для областей определения которых заданный объект является надмножеством; отношений, область определения каждого из которых строго пересекается с заданным объектом).</li></ul>

<p>
В <b>sc-модели базы знаний</b> каждая семантическая окрестность представляется в виде соответствующего sc-текста. Для явного введения (задания) этой семантической окрестности в рамках sc-модели базы знаний необходимо:</p>

<ol>
<li>явно ввести sc-узел, обозначающий эту семантическую окрестность;</li>
<li>явно связать введенный sc-узел sc-дугами основного вида со всеми элементами обозначаемого им sc-текста;</li>
<li>с помощью ролевого отношения <b><i>быть центром семантической окрестности</i></b> явно указать центральный элемент семантической окрестности;</li>
<li>явно связать введенный sc-узел sc-дугой основного вида со специальным sc-узлом, обозначающим <b><i>класс sc-структур, являющихся семантическими окрестностями.</i></b></li></ol>

<p>
После этого можно описывать различные характеристики (в частности, типологию) явно введенной семантической окрестности, а также различные связи этой семантической окрестности с другими фрагментами базы знаний.</p>

<p>
<b>7. Принцип ориентации на графовые языки программирования</b></p>

<p>
Для описания способов решения задач и поведения агентов над общей графодинамической памятью предлагается использовать <b>графовые языки программирования</b>, которые ориентированы на обработку унифицированных семантических сетей и программы которых сами являются унифицированными семантическими сетями.</p>

<p>
Если все используемые в интеллектуальной системе графовые языки программирования привести к общему унифицированному стандарту – к SC-коду (это требует представления в виде sc-текстов не только самих программ, но и обрабатываемых ими данных), то можно достаточно эффективно решать проблему формализации семантической совместимости программ, написанных не только на одном, но и на разных языках программирования.</p>

<p>
В традиционных языках программирования синтаксическая структура и семантика хранящихся в памяти обрабатываемых данных отдается на откуп программисту, в результате чего это делается по принципу "кто во что горазд". О какой же семантической совместимости программ после этого можно говорить. В этом смысле традиционные языки программирования "хромают на одну ногу".</p>

<p>
Наряду с применением в интеллектуальных системах множества sc-языков самого различного назначения, востребованным является использование целого семейства <u>совместимых</u> sc-языков программирования, которые могут иметь разный уровень, могут быть последовательными, процедурными и декларативными. </p>

<p>
Важнейшей особенностью всех этих языков является использование ассоциативного доступа к обрабатываемым фрагментам хранимого в графодинамической памяти sc-текста.</p>

<p>
Операционная семантика каждого такого графового языка программирования (точнее, sc-языка программирования) задается коллективом агентов над общей графодинамической памятью, которые обеспечивают интерпретацию любой программы указанного языка программирования, хранящейся вместе с обрабатываемой информацией в указанной графодинамической памяти.</p>

<p>
Программы представленные в виде семантической сети и описывающие обработку семантических сетей, а также соответствующие им языки программирования фактически открывают новую страницу в теории программирования, которую можно назвать семантической теорией программ и языков программирования.</p>

<p>
Основным лейтмотивом такой теории должно быть обеспечение семантической совместимости программ и языков программирования.</p>

<p>
<b>8. Принцип унификации формального описания поведения агентов обработки информации в графодинамической семантической памяти</b></p>

<p>
Из всех используемых в интеллектуальной системе графовых языков программирования (а, точнее, из всех sc-языков программирования) педлагается выделить <b>базовый графовый язык программирования</b>,  ориентированный на описание агентов, работающих над общей графодинамической памятью, в которой хранятся и обрабатываются <u>унифицированные</u> семантические сети.</p>

<p>
Выделение базового sc-языка программирования предназначено для унификации формального описания поведения агентов, работающих над общей графодинамической памятью.</p>

<p>
Такой базовый sc-язык программирования будем называть <b><i>языком SCP</i></b> (Semantic Code Programming), а написанные на нем программы будем называть <b><i>scp-программами</i></b>.</p>
<p>Перечислим основные особенности языка SCP:</p>

<ul>
<li>язык SCP относится к классу <b><u>графовых</u> языков программирования</b>;</li>
<li>язык SCP ориентирован на обработку <b>унифицированных <u>семантических сетей</u></b> (sc-текстов), хранимых в семантической памяти;</li>
<li>программы языка SCP представляются также в виде унифицированных семантических сетей (sc-текстов), т. е. язык SCP принадлежит классу sc-языков;</li>
<li>язык SCP ориентирован на описание <b><u>параллельной асинхронной</u> обработки</b> sc-текстов, хранимых в семантической памяти;</li>
<li>язык SCP использует <b><u>ассоциативный</u> доступ</b> к фрагментам обрабатываемых sc-текстов;</li>
<li>язык SCP является процедурным языком программирования низкого уровня, предназначенным для описания поведения агентов, работающих над семантической памятью;</li>
<li>уникальной особенностью языка SCP является то, что на нем можно писать <b>реконфигурируемые программы</b>, т. е.  программы, которые в процессе своего выполнения могут <u>изменять сами себя</u> (удалять или порождать операторы, корректировать порядок их выполнения и т. п.). Такая особенность языка SCP обусловлена не только тем, что scp-программы и обрабатываемые ими данные хранятся в общей памяти, но и тем, что они принадлежат <u>одному и тому же</u>, базовому языку (SC-коду), имеющему четко заданную семантическую интерпретацию.</li></ul>

<p>
Более подробно графовый язык программирования SCP и технология проектирования scp-программ рассмотрены в работах [Голенков и др., 2001], [Гулякина и др., 2012].</p>

<p>
<b>9. Принцип унификации различных семантических моделей обработки знаний</b></p>

<p>
На основе унифицированных семантических сетей (sc-текстов) предлагается уточнить понятие <b>унифицированной модели обработки информации</b>, а также понятие унифицированной модели решения задач.</p>

<p>
Все указанные абстрактные модели будем называть <b>sc-моделями обработки знаний</b> или <b>sc-машинами</b>, поскольку в основе их лежит использование SC-кода. Каждая такая модель (sc-машина) представляет собой многоагентную систему, состоящую:</p>

<ol>
<li>из графодинамической памяти, в которой хранятся и обрабатываются тексты SC-кода – такую память будем называть <b>sc-памятью</b>;</li>
<li>из коллектива агентов, работающих над общей для них sc-памятью и взаимодействующих между собой только через эту память – такие агенты будем называть <b>sc-агентами</b>.</li></ol>

<p>
Очевидно, что sc-модели обработки знаний являются частным, унифицированным видом графодинамических моделей параллельной асинхронной обработки информации.</p>

<p>
Каждый sc-агент реагирует на соответствующий ему класс ситуаций и/или событий, происходящих в sc-памяти, и осуществляет определенное преобразование sc-текста, находящегося в семантической окрестности обрабатываемой ситуации и/или события. Типология sc-агентов достаточно богата. В частности, можно выделить следующие классы sc-агентов:</p>

<ul>
<li>sc-агенты, обеспечивающие интерпретацию программ различных sc-языков программирования высокого уровня;</li>
<li>sc-агенты информационного поиска;</li>
<li>sc-агенты, обеспечивающие реализацию правил логического вывода, соответствующих самым различным логическим исчислениям;</li>
<li>sc-агенты сведения задач к подзадачам;</li>
<li>sc-агенты анализа качества хранимой базы знаний, в частности, ее корректности, полноты;</li>
<li>sc-агенты обнаружения и автоматического склеивания синонимичных sc-элементов;</li>
<li>sc-агенты автоматического устранения некоторых ошибок в базе знаний;</li>
<li>sc-агенты удаления информационного мусора (в частности, удаления фрагментов базы знаний, которые редко востребованы и могут быть достаточно легко восстановлены в случае их отсутствия);</li>
<li>sc-агенты, обеспечивающие трансляцию вводимой информации с различных внешних языков в SC-код;</li>
<li>sc-агенты, обеспечивающие трансляцию sc-текстов, вводимых пользователю на различные внешние языки;</li>
<li>рецепторные sc-агенты;</li>
<li>эффекторные sc-агенты.</li></ul>

<p>
В понятии sc-машины набор агентов не задается, т.е. могут существовать разные sc-машины с разным набором sc-агентов. Несколько разных sc-машин можно <b>интегрировать</b>. С формальной точки зрения это сделать не очень сложно:</p>

<ol>
<li>интегрировать sc-текст, описывающий текущее состояние взаимодействия sc-агентов одной sc-машины, с аналогичным sc-текстом другой sc-машины;</li>
<li>полученный интегрированный sc-текст поместить в sc-память интегрированной sc-машины;</li>
<li>в интегрированную sc-машину включить все sc-агенты первой интегрируемой sc-машины и все sc-агенты второй интегрируемой sc-машины.</li></ol>

<p>
Более того, одна sc-машина может <b>интерпретировать</b> другую. Т. е. при интерпретации sc-машин можно не выходить за пределы класса sc-машин. Для этого необходима разработка целого семейства sc-языков  программирования различного уровня. Тексты (программы) всех этих языков должны храниться в sc-памяти, т.е. должны быть семантическими сетями, представленными в SC-коде. Операционная семантика (интерпретация) каждого из этих языков задается определенным набором sc-агентов, процедура выполнения (поведения) каждой из которых описывается программой, написанной на языке более <u>низкого уровня</u>.</p>

<p>
В абстрактных sc-машинах можно выделить следующие языки программирования:</p>

<ul>
<li>Семейство sc-языков программирования высокого и сверхвысокого уровня (как процедурных, так и непроцедурных). Тексты программ этих языков хранятся в базе знаний интеллектуальной системы и описывают способы решения различных классов задач в соответствующих предметных областях.</li>
<li>Базовый sc-язык программирования (язык SCP), на котором описываются sc-агенты и интерпретации sc-языков программирования высокого и сверхвысокого уровня, а также sc-операции, обеспечивающие интерпретацию различных логических исчислений, различных моделей интеллектуального решения задач.</li>
<li>SC-язык программирования, на котором описываются sc-агенты интерпретации базового sc-языка программирования. Фактически, это 1-й язык микропрограмм для <b>sc-компьютера</b>, обеспечивающего аппаратную интерпретацию базового sc-языка программирования (языка SCP).</li>
<li>При необходимости можно ввести 2-й язык микропрограммирования, описывающий интерпретацию 1-го и т.д.</li></ul>

<p>
На основе понятия абстрактной sc-машины можно уточнить понятие унифицированной логико-семантической модели интеллектуальной системы. Такую унифицированную модель интеллектуальной системы будем называть абстрактной <b>sc-моделью интеллектуальной системы</b> или, сокращенно, <b>sc-системой</b>. Абстрактная sc-система включает в себя:</p>

<ul>
<li>интегрированную базу всех (!) знаний, которые необходимы для функционирования интеллектуальной системы и которые представлены в виде интегрированного sc-текста (такую семантическую модель базы знаний будем называть <b>sc-моделью базы знаний</b> или sc-текстом базы знаний);
<li>абстрактную <b>sc-машину</b>, в памяти которой хранится указанный sc-текст базы знаний.</p>

<p>
Нетрудно заметить, что sc-текст базы знаний интеллектуальной системы является формальным и унифицированным уточнением того, что должна <u>знать</u> проектируемая интеллектуальная система, а sc-машина интеллектуальной системы и, в первую очередь, набор входящих в ее состав sc-агентов является формальным и унифицированным уточнением того, что должна проектируемая интеллектуальная система <u>уметь</u> делать со своими знаниями.</p>

<p>
Подчеркнем также, что четкое выделение абстрактного семантического уровня интеллектуальной системы позволяет не только обеспечивать их семантическую совместимость интеллектуальных систем, но и сформировать критерии сравнения интеллектуальных систем по уровню их возможностей. Очевидно, что уровень возможностей интеллектуальной системы определяется качеством (корректностью, полнотой, многообразием) ее <u>знаний</u> и эффективностью ее <u>умений</u> (т.е. эффективностью используемых ее моделей решения задач).</p>

<p>
Заметим также, что абстрактную логико-семантическую модель в принципе можно построить для любой компьютерной системы (как для интеллектуальной системы, так и для компьютерной системы традиционного вида), обеспечивая их семантическую совместимость на абстрактном логико-семантическом уровне.</p>

<p>
<b>10. Принцип унификации семантических моделей информационного поиска</b></p>

<p>
На основе унифицированных семантических сетей (т.е. на основе SC-кода) предлагается обеспечить построение <b>унифицированных семантических моделей информационного поиска</b> (унифицированных семантических моделей ассоциативного доступа к информации, хранимой в семантической памяти). </p>

<p>
Ассоциативный доступ – это доступ, основанный не (!) на знании того, где находится искомая (требуемая) информация (в частности, на знании адреса или имени соответствующей области памяти), а на знании того, как искомая информация связана с известной информацией, хранимой в памяти, т.е. на знании некоторой спецификации искомой информации.</p>

<p>
Эффективность организации информационного поиска в базе знаний интеллектуальной системы во многом определяет эффективность самой интеллектуальной системы. Это обусловлено тем, что время, затрачиваемое интеллектуальной системой на поиск нужных в текущий момент знаний и навыков, занимает, мягко говоря, не меньше половины времени затрачиваемого на решение задачи в целом.</p>

<p>
Унифицированная семантическая модель информационного поиска, которую будем называть <b>sc-моделью информационного поиска</b>, включает в себя:</p>

<ol>
<li><b>SC-язык вопросов</b>, с помощью которого в виде sc-текстов осуществляется описание (спецификация) запрашиваемых (искомых) фрагментов всего интегрированного sc-текста, хранимого в текущий момент в sc-памяти (т.е. sc-текста, который является sc-моделью базы знаний). Тексты, принадлежащие SC-языку вопросов, будем называть <i>sc-вопросами</i>.</li>
<li><b>SC-язык оформления ответов</b>, с помощью которого осуществляется явное выделение sc-текстов, являющихся ответами, и явное описание их связи с явно выделенными sc-текстами, которые представляют вопросы, соответствующий указанным ответам.</li>
<li>Семейство информационно-поисковых sc-агентов, каждый из которых реагирует на соответствующий ему тип sc-вопроса (который при этом должен быть инициирован) и выполняет соответствующую поисковую процедуру в sc-памяти.</li></ul>

<p>
Семантическая типология вопросов является предметом отдельного рассмотрения. Приведем фрагмент такой типологии, чтобы проиллюстрировать  семантическую мощность sc-языка вопросов.</p>

<p>
Прежде всего, по аналогии с логическими формулами множество вопросов разбивается на:</p>

<ul>
<li><b><i>атомарные вопросы;</i></b></li>
<li><b><i>неатомарные вопросы</i></b>, каждый из которых представляет собой конечное множество вопросов.</li></ul>

<p>
Компонентами неатомарного вопроса могут быть как атомарные, так и неатомарные вопросы. При этом, если построить орграф, вершинами которого будут знаки всех вопросов, входящих в состав заданного неатомарного вопроса, а дуги которого будут связывать знаки неатомарных вопросов, входящих в состав заданного неатомарного вопроса, с их компонентами, то этот орграф будет деревом, все конечные вершины которого являются знаками атомарных вопросов. Частным видом неатомарного вопроса является конъюнктивный вопрос, ответом на который является конъюнкция (интеграция) ответов на все вопросы, являющиеся компонентами этого конъюнктивного вопроса.</p>

<p>
Поскольку в общем случае вопросу может соответствовать <u>несколько</u> правильных ответов (т.е. ответов, удовлетворяющих, релевантных, соответствующих заданному вопросу), множество вопросов разбивается на:</p>

<ul>
<li>вопросы, запрашивающие все правильные ответы;</li>
<li>вопросы, запрашивающие один (или по крайней мере один) правильный ответ;</li>
<li>вопросы, запрашивающие несколько разнообразных правильных ответов;</li>
<li>вопросы, запрашивающие точно указанное число (большее единицы) правильных ответов.</li></ul>

<p>
Специальным видом неатомарных вопросов являются <b><i>сколько-вопросы</i></b>, запрашивающие не сами правильные ответы некоторого вопроса (который может быть как атомарным, так и неатомарным, и который является единственным компонентом сколько-вопроса), а количество таких правильных ответов.</p>

<p>
Приведем некоторые типы атомарных вопросов:</p>

<ul>
<li><b><i>какой-вопрос атомарного вида</i></b>. Каждый такой вопрос запрашивает фрагменты базы знаний, <u>изоморфные</u> заданному <b>образцу</b>, который может иметь <u>произвольный</u> размер, произвольную конфигурацию и который может быть представлен не только <u>логической формулой существования</u> в которой квантор существования действует на конъюнкцию <u>атомарных логических формул</u>, но также и логической формулой существования, в которой квантор существования действует на логическую формулу <u>произвольного вида</u>. Суть атомарного <i>какой-вопроса</i> заключается в поиске знаков таких объектов, которые заданным образом связаны с другими известными и неизвестными (искомыми) объектами, т.е. в поиске знаков таких объектов, которые удовлетворяют заданным требованиям. На основе <i>какой-вопросов</i> атомарного вида строится важный класс неатомарных вопросов ключевыми компонентами которых являются атомарные <i>какой-вопросы</i>, а остальными компонентами – вопросы любого вида, в формулировках которых используются переменные, входящие в состав соответствующих ключевых <i>какой-вопросов</i>;</li>
<li><b><i>запрос всех элементов</i></b> заданного конечного множества (чаще всего – это множество из элементов некоторой структуры);</li>
<li><b><i>запрос внешней информационной конструкции</i></b>, представленной некоторым файлом в том или ином формате;</li>
<li>запрос полного текста заданного высказывания;</li>
<li><b><i>ли-вопрос</i></b>, запрашивающий факт истинности или ложности заданного высказывания в рамках заданной формальной теории;</li>
<li><b><i>вопрос выбора альтернатив</i></b>, запрашивающий одно или несколько истинных высказываний из заданного множества высказываний;</li>
<li><b><i>почему-вопрос</i></b>, запрашивающий обоснование (доказательство) истинности заданного высказывания;</li>
<li><b><i>что-это-вопрос</i></b>, запрашивающий основные сведения об указываемом объекте. Фактически, речь идет о выделении из базы знаний семантической окрестности, "центром" которой является знак указываемого объекта. Таким объектом может быть все, что угодно – понятие, предметная область, формальная теория, высказывание, любая структура, материальный объект.</li>
<li><b><i>запрос общих свойств</i></b> объектов, принадлежащих заданному классу;</li>
<li><b><i>запрос идентифицирующих признаков</i></b> заданного объекта. Здесь запрашиваются фрагменты базы знаний, каждый из которых <u>однозначно</u> (!) определяет (устанавливает, идентифицирует) заданный объект. Если заданным объектом является понятие, то таким идентифицирующим признаком является либо определение этого понятия, либо соответствующая теорема о необходимости и достаточности;</li>
<li><b><i>запрос связей между заданными объектами;</i></b></li></li>
<li><b><i>запрос сравнительного анализа заданных объектов;</i></b></li>
<li><b><i>запрос сходств</i></b> заданных объектов (сходства, аналогии – это частный вид связей между объектами);</li>
<li><b><i>запрос отличий</i></b> заданных объектов (отличия объектов – это тоже частный вид связей между ними);</li>
<li><b><i>запрос плана решения</i></b> заданной конкретной задачи, т.е. плана достижения заданной цели в заданных конкретных условиях;</li>
<li><b><i>запрос обобщенного способа решения</i></b> любой задачи из заданного класса задач. Таким обобщенным способом может быть алгоритм, декларативная (непроцедурная) программа, нестрогое предписание (рекомендация);</li>
<li><b><i>зачем-вопрос</i></b>, запрашивающий то, какой надцели соответствует заданная цель, которая может быть сформулирована как в декларативной, так и в процедурной форме.</li></ul>

<p>
Список типов атомарных вопросов можно продолжить, но почти все они будут подтипами (подмножествами) перечисленных типов вопросов. В основе sc-языка вопросов лежит построение онтологии вопросов, в рамках которой четко прописываются все теоретико-множественные (и, в первую очередь, родо-видовые) связи между <u>всеми</u> выделенными типами и подтипами вопросов. При этом в формулировке <u>каждого</u> конкретного sc-вопроса <u>явным образом</u> отражаются иерархия <u>всех</u> типов вопросов, которым принадлежит данный конкретный sc-вопрос. Для этого каждому типу вопросов ставится в соответствие ключевой sc-узел, обозначающий этот тип вопросов.</p>

<p>
В заключение заметим, что в <b>SC-языке оформления ответов</b> кроме отношения релевантности, связывающего вопросы с правильными на него ответами, используются языковые средства, описывающие качество, полноту ответов. Это вызвано тем, что некоторые типы вопросов предполагают наличие целого множества правильных ответов, но разного качества, с разной степенью полноты.</p>

<p>
<b>11. Принцип унификации семантических моделей интеграции знаний</b></p>

<p>
На основе унифицированных семантических сетей предлагается построение <b>унифицированных семантических моделей интеграции знаний</b> (понимания знаний) и использовать эти модели (1) как основу процесса приобретения интеллектуальной системой новых знаний как со стороны конечных пользователей, так и со стороны разработчиков; (2) как основу интеграции программ и различных семантических моделей расширения задач; (3) как основу интеграции абстрактных логико-семантических моделей интеллектуальных систем.</p>
<p>Процесс интеграции двух семантических сетей рассмотрим как систему следующих взаимодействующих подпроцессов, некоторые из которых могут выполняться параллельно:</p>
<ul>
<li>приведение интегрируемых семантических сетей к унифицированному виду, т.е. представление (запись) их в SC-коде;</li>
<li>согласование ключевых узлов и онтологий, используемых в интегрируемых sc-текстах. Очевидно, что полностью автоматизировать такое согласование невозможно, поэтому разработчикам интегрируемых фрагментов баз знаний и целых баз знаний необходимо <u>уметь договариваться</u> друг с другом;</li>
<li>выделение в интегрируемых sc-текстах таких sc-элементов, которые имеют глобальные (уникальные) идентификаторы (внешние имена);</li>
<li>выделение в интегрируемых sc-текстах sc-элементов, имеющих локальные идентификаторы вместе с областью действии каждого такого идентификатора. Область действия локального идентификатора – это такой фрагмент базы знаний, в рамках которого разные sc-элементы, имеющие этот локальный идентификатор, считаются синонимичными;</li>
<li>склеивание sc-элементов, имеющих одинаковые глобальные идентификаторы;</li>
<li>склеивание sc-элементов, имеющих одинаковые локальные идентификаторы, если каждый их этих sc-элементов принадлежит области действия своего локального идентификатора и области действия локального идентификатора другого sc-элемента;</li>
<li>склеивание sc-элементов на основании однозначности используемых алгебраических операций;</li>
<li>склеивание sc-элементов на основании логических высказываний о существовании единственности;</li>
<li>склеивание кратных связок, принадлежащих отношениям:</li>
<ul>
<li>не имеющим кратных связок;</li>
<li>имеющих кратные связки, но не для заданных типов компонентов (например, кратные связки принадлежности не могут выходить из знаков канторовских множеств).</li></ul></ul>

<p>
Таким образом, интеграция семантических сетей, т.е. процесс погружения (понимания) одной семантической сети в другую – это нетривиальный процесс рассуждений, направленный на выявление пар синонимичных элементов семантической сети на основе определенных знаний, имеющихся в базе знаний интеллектуальной системы.</p>

<p>
<b>12. Принцип унификации различных семантических моделей решения задач и унификации интеграции таких моделей</b></p>

<p>
В рамках проектируемой интеллектуальной системы предлагается обеспечить использование не только самых различных видов знаний, но и самых <b>различных моделей и стратегий решения задач</b>.</p>

<p>
Для этого необходимо акцентировать внимание не столько на разработку новых моделей решения задач, сколько на унификацию и интеграцию в рамках проектируемых интеллектуальных систем уже разработанных и хорошо зарекомендовавших себя моделей (дедуктивных, индуктивных, абдуктивных, четких, нечетких, универсальных, специализированных…). Подчеркнем то, что в разных проектируемых интеллектуальных системах могут быть востребованы самые разные сочетания известных моделей и стратегий решения задач. Подавляющее число моделей представления знаний и решения задач не являются альтернативными и <u>дополняют друг друга</u>. Не составляют исключение и такие классы моделей, как фреймовые, логические, продукционные.</p>

<p>
Рассмотренное выше понятие вопроса и его формализация является основой не только для информационно-поисковых моделей, но и для самых различных моделей решения задач. С точки зрения решателя задач вопрос – это <b>непроцедурная формулировка информационной цели</b>, т.е. декларативная формулировка некоторой информационной цели, которая описывает спецификацию (свойства) той информации, которую <u>требуется</u> либо найти, если она уже присутствует в текущем состоянии базы знаний, либо построить (сгенерировать, вывести), если она отсутствует в текущем состоянии памяти. Таким образом, вопрос можно считать описанием целевого (требуемого) состояния обрабатываемой базы знаний (а, точнее, определенного фрагмента этой базы знаний). Вопрос также можно считать одним из видов <u>метазнаний</u>, описывающих (специфицирующих) наше <u>незнание</u>, т.е. наше знание о том, что мы не знаем, но хотели бы знать.</p>

<p>
Вопросы могут инициироваться (задаваться) как пользователями, так и самой системой. Это означает, что в процессе обработки информации интеллектуальная система сама себе может задавать (генерировать, порождать) вопросы. Если инициирован некоторый sc-вопрос, то сначала активизируются соответствующие агенты информационного поиска в "надежде" на то, что запрашиваемый ответ (или ответы) на указанный sc-вопрос уже присутствует в текущем состоянии базы знаний. И только после того, как информационно-поисковые sc-агенты обнаружат отсутствие ответа в текущем состоянии базы знаний, начинается работа решателя задач, направленная на генерацию (построение, порождение, вывод) требуемого ответа.</p>

<p>
Кроме вопроса используется также и <b>процедурная формулировка информационной цели</b> – это описание (спецификация) некоторого действия, которое требуется выполнить и которое направлено на преобразование (изменение состояния) базы знаний, хранимой в некоторой памяти. Указанное действие, выполняется либо одним sc-агентом (в случае, если это элементарное действие над sc-памятью), либо несколькими sc-агентами и порождает определенное событие (изменение состояния sc-памяти).</p>

<p>
Для унификации различных моделей решения задач необходимо уточнить не только понятие <b>информационной цели</b>, но и понятие <b>информационной задачи</b>. Информационная задача задается (1) формулировкой информационной цели, т.е. описанием того, <u>что требуется</u>, и (2) той хранимой в памяти информацией, которая семантически связана с заданной информационной целью, является контекстом этой информационной цели, т.е. тем, <u>что дано</u>. В пределе, контекстом информационной цели можно считать текущее состояние всей хранимой базы знаний.</p>

<p>
Формальное рассмотрение контекстов различных информационных задач требует разработки специальных языковых средств, предназначенных для описания <u>текущего состояния</u> хранимой базы знаний, а, точнее, для описания "грани" между тем, что в текущем состоянии базы знаний известно и тем, что неизвестно. К числу таких языковых средств, в частности, относятся следующие ключевые узлы, являющиеся знаками нестационарных множеств (т.е. множеств, которые в разные моменты времени могут иметь разные элементы):</p>

<ul>
<li>быть sc-дугой нечеткой принадлежности (такая sc-дуга связывает sc-узел, обозначающий некоторое множество, с sc-элементом о котором нам в текущий момент времени не известно, принадлежит он указанному множеству или нет);</li>
<li>быть построенным конечным множеством (у каждого такого множества в текущем состоянии базы знаний известны и явно указаны <u>все</u> его элементы);</li>
<li>быть построенным высказыванием (для каждого такого высказывания в текущем состоянии базы знаний представлен не только его знак, но и полный текст);</li>
<li>быть построенной внешней информационной конструкцией (файлом);</li>
<li>быть аксиоматизированной формальной теорией;</li>
<li>быть построенным рассуждением (обоснованием, доказательством, решением);</li>
<li>быть построенной программой.</li></ul>

<p>
<b>13. Принцип унификации интегрированных логико-семантических моделей интеллектуальных систем и унификации интеграции таких моделей</b></p>

<p>
Интегрированная унифицированная семантическая модель интеллектуальной системы в целом влючает в себя унифицированную логико-семантическую модель ее базы знаний, содержащей все необходимые ей знания, и унифицированную логико-семантическую модель ее машины обработки знаний.</p>

<p>
При этом ключевые знаки агентов, входящих в состав машины обработки знаний обязательно должны быть представлены в базе знаний.</p>

<p>
Главное свойство интеллектуальной системы – не те интеллектуальные знания и навыки, не те интеллектуальные способности, которые она имеет в текущий момент, а <u>мета</u>способность приобретать <u>любые</u> необходимые ей <u>новые</u> знания и навыки. А для этого интеллектуальная система, как минимум, должна уметь интегрировать эти приобретаемые знания и навыки. Следовательно, проблема формализации интеграции знаний и навыков является центральной для деятельности интеллектуальных систем.</p>

<p>
Принципиальное свойство интеграции двух интеллектуальных систем заключается в следующем. Пусть имеется две интеллектуальные системы <i>s1, s2,</i> первая из которых способна решать задачи из множества <i>q1</i>, в вторая – <i>q2</i>. В результате простого соединения этих систем мы получаем систему, которая способна решать задачи из множества <i>(q1 &cup; q2)</i>. Тогда как в результате интеграции мы получаем систему, которая способна решать значительно большее число задач, чем <i>(q1 &cup; q2)</i>. Такое расширение числа решаемых задач происходит за счет тех задач, для решения которых некоторые (но не все) знания и навыки находятся в системе <i>s1</i>, а другие – в системе <i>s2</i>.</p>

<p>
Таким образом, при интеграции интеллектуальных систем происходит приобретение нового качества "на стыке" интегрируемых систем, когда для решения некоторых задач одна часть необходимых знаний и/или умений находится в одной интегрируемой системе, а другая часть – в другой системе.</p>

<p>
От унифицированной семантической модели интеграции знаний (точнее, sc-текстов) можно достаточно легко перейти к интеграции sc-моделей интеллектуальных систем, поскольку после интеграции sc-моделей баз знаний интегрируемых интеллектуальных систем интеграция соответствующих им наборов sc-агентов сводится к простому теоретико–множественному объединению указанных множеств sc-агентов.</p>

<p>
<b>14. Принцип унификации визуализации унифицированного абстрактного семантического представления различного вида знаний</b></p>

<p>
В качестве основы организации графического пользовательского интерфейса предлагается использовать язык унифицированного визуального представления абстрактных унифицированных семантических сетей в виде, близком к изоморфному.</p>

<p>
Указанный язык графического изображения sc-текстов назван SCg-кодом (Semantic Code graphical). Подчеркнем, что следует четко отличать язык абстрактных унифицированных семантических сетей (SC-код), который абстрагируется от того, как должны быть физически представлены узлы и коннекторы текстов этого языка (sc-текстов), и язык графического изображения таких семантических сетей. Т.е. абстрактная семантическая сеть и ее рисунок – принципиально разные вещи.</p>

<p>
С помощью SCg-кода осуществляется отображение на экране не только пользовательских сообщений, адресуемых системе, и не только сообщений, адресуемых пользователю, но и всей остальной информации, необходимой для организации работы пользователя (прежде всего – это элементы управления интерфейсом). Такая унификация отображаемой пользователю информации дает возможность организовать взаимодействие пользователя с help-системой точно так же, как и его взаимодействие с основной (предметной) системой.</p>

<p>
Трактовка элементов управления пользовательским интерфейсом как элементов отображаемого на экране SCg-текста позволяет:</p>

<ol>
<li>унифицировать представлений <u>любой</u> информации, отображаемой на экране;</li>
<li>унифицировать способы инициирования различных вопросов, касающихся <u>любой</u> отображаемой на экране информации (в том числе, и элементов управления);</li></ol>

<p>
Для того, чтобы четко отделить те средства SCg-кода, которые обусловлены самим SC-кодом, от тех средств, которые обусловлены стремлением повысить наглядность SCg-текстов, введем ядро SCg-кода (или, просто, SCg-ядро), алфавит которого взаимно однозначно соответствует алфавиту SC-кода и, соответственно этому, тексты которого изоморфны (!) семантически эквивалентным текстам SC-кода.</p>

<p>
Переход от SCg-ядра к SCg-коду заключается в ослаблении требований, предъявляемых к изображениям семантических сетей, в целях обеспечения удобства для человеческого восприятия. Такое ослабление осуществляется в следующих направлениях: вводится приписывание идентификаторов изображаемых sc-элементов, расширяется алфавит графических примитивов, допускается уникальное изображение некоторых sc-узлов, допускается синонимия sc.g-элементов, но при этом синонимичным элементам должны быть приписаны одинаковые идентификаторы, вводятся специальные графические средства, направленные на повышение наглядности (шинные линии, контуры).</p>

<p>
Заметим также, что кроме SCg-кода для внешнего представления абстрактных унифицированных семантических сетей используются также и другие языки:</p>

<ul>
<li>SCs-код, обеспечивающий представление унифицированных абстрактных семантических сетей (sc-текстов) в виде, близком к традиционным текстам;</li>
<li>SCn-код, обеспечивающий гипертекстовое представление абстрактных sc-текстов, предназначенное для оформления исходных текстов баз знаний.</li></ul>

<p>
Более подробно различные языки внешнего представления абстрактных sc-текстов вместе с большим количеством примеров рассмотрены в работах [Голенков и др., 2001].</p>

<p>
<b>15. Принцип унификации семантических моделей пользовательских интерфейсов</b></p>

<p>
<b>Пользовательский интерфейс</b> интеллектуальной системы, построенной на основе предлагаемой технологии, предлагается рассматривать как <b>специализированную интеллектуальную систему</b>, построенную по той же технологии и предназначенную для <b>трансляции адресуемых пользователю сообщений</b> с внутреннего абстрактного семантического языка представления знаний (SC-кода) на тот или иной внешний язык, тексты которого отображаются пользователю в удобном для него виде, а также для <b>трансляции пользовательских сообщений</b> с внешнего языка внутренний семантический язык интеллектуальной системы (т.е. в SC-код).</p>

<p>
Трактовка пользовательских интерфейсов как интеллектуальных систем и унификация семантических моделей таких систем дает возможность:</p>

<ol>
<li>унифицировать проектирование пользовательских интерфейсов;</li>
<li>легко наращивать возможности пользовательских интерфейсов;</li>
<li>легко интегрировать пользовательские интерфейсы с предметными (основными) интеллектуальными системами;</li>
<li>неограниченно использовать базу знаний предметных интеллектуальных систем для семантического анализа и понимания вводимой пользователем информации (в частности, естественно-языковых текстов).</li></ol>

<p>
<b>16. Принцип модульного проектирования интеллектуальных систем на основе постоянно расширяемых библиотек многократно используемых семантически совместимых компонентов</b></p>

<p>
В целях ускорения процесса проектирования интеллектуальных систем предлагается создать общую библиотеку многократно используемых семантически совместимых компонентов интеллектуальных систем, на основе которой разработать методику модульного (компонентного, сборочного) проектирования интеллектуальных систем.</p>

<p>
В указанной библиотеке можно выделить следующие разделы (частные библиотеки):</p>

<ul>
<li>библиотека многократно используемых компонентов баз знаний. Прежде всего, в эту библиотеку входят самые различные по содержанию, но семантически совместимые онтологии. Кроме того, сюда относятся различные "джентльменские наборы" знаний, которыми должны владеть "образованные" интеллектуальные системы. К таким знаниям, в частности, относятся базовые знания по арифметике, базовые знаний по теории множеств (каждая интеллектуальная система должна, по крайней мере, отличать элемент заданного множества от его подмножества), базовые знания по теории отношений (каждая интеллектуальная система должна уметь отличать бинарное отношение от многоместного отношения, должна понимать, что такое соответствие), базовые знания по логике (каждая интеллектуальная система должна понимать, что такое теория, высказывание, определение, переменная должна отличать фактографическое высказывание от высказывания, не являющегося фактографическим, должна уметь отличать высказывание от логической формулы, не являющейся высказыванием) и многие другие знания, востребованность которых может быть самой разной;</li>
<li>библиотека компонентов семантических моделей информационного поиска. Сюда, прежде всего, входят различные информационно-поисковые агенты;</li>
<li>библиотека компонентов семантических моделей интеграции знаний и машин обработки знаний;</li>
<li>библиотека интерпретаторов программ, соответствующих различным языкам программирования;</li>
<li>библиотека различных стратегий решения задач, различных моделей решения задач и агентов, входящих в состав таких моделей;</li>
<li>библиотека компонентов пользовательских интерфейсов.</li></ul>

<p>
Все компоненты, включаемые в состав общей библиотеки компонентов интеллектуальных систем, оформляются как компоненты интеллектуальной собственности (intellectual property), поэтому будем их также называть ip-компонентами.</p>

<p>
Особо подчеркнем то, что модульное проектирование интеллектуальных систем возможно только в том случае, если отбор компонентов, включаемых в состав рассмотренной библиотеки, будет осуществляться на основе тщательного анализа качества этих компонентов. Одним из важнейших критериев такого анализа является семантическая совместимость анализируемых компонентов со всеми компонентами, имеющимися в текущей версии библиотеки.</p>

<p>
Для обеспечения семантической совместимости таких компонентов интеллектуальных систем, которые являются унифицированными семантическими моделями (sc-моделями знаний, sc-моделями машин обработки знаний, sc-агентов, sc-моделями интеллектуальных подсистем), необходимо (1) согласовать семантику (смысл) всех используемых ключевых узлов и (2) согласовать глобальные идентификаторы ключевых узлов, используемых в разных компонентах. После этого интеграция всех компонентов, входящих в состав библиотеки, и в любых комбинациях осуществляется автоматически, без вмешательства разработчика.</p>

<p>
<b>17. Принцип платформенной независимости проектирования интеллектуальных систем</b></p>

<p>
Для максимальной платформенной независимости технологии предлагается обеспечить четкое разделение процесса проектирования формального описания логико-семантической модели разрабатываемой интеллектуальной системы от процесса реализации (интерпретации) этой модели на той или иной платформе.</p>

<p>
Подчеркнем при этом следующее. Если каждой интеллектуальной системе соответствует своя уникальная логико-семантическая модель, то каждый интерпретатор абстрактных логико-семантических моделей интеллектуальных систем должен обеспечивать интерпретацию целого класса таких моделей, а в идеале – интерпретацию любой такой модели. Следовательно, разработка указанных интерпретаторов может осуществляться абсолютно  независимо от разработки логико-семантических моделей конкретных интеллектуальных систем.</p>

<p>
Таким образом, SC-код, обеспечивающий унификацию семантического представления любых знаний, вместе с языком SCP, обеспечивающим унификацию формального описания агентов, работающих над семантической памятью, являясь средством унификации логико-семантических моделей интеллектуальных систем, выполняют в рамках предлагаемой технологии роль, аналогичную той, которую выполняет язык VHDL в современных микроэлектронных технологиях. В лице SC-кода и языка SCP мы имеем <u>стандарт</u> полного (!) формального описания логико-семантических моделей интеллектуальных систем, обеспечивающий независимость проектирования абстрактных логико-семантических моделей конкретных интеллектуальных систем от разработки различных вариантов реализации (различных вариантов их интерпретации на различных платформах). Такой стандарт является своего рода "водоразделом" между полным платформенно-независимым описанием интеллектуальной системы (абстрактной логико-семантической моделью) и платформенно зависимой реализацией (интерпретацией) этой абстрактной модели.</p>

<p>
Полностью построенная абстрактная логико-семантическая модель проектируемой интеллектуальной системы:</p>

<ol>
<li>является открытой, поскольку ее можно легко пополнять новыми знаниями и навыками, интегрируя их в текущую версию модели;</li>
<li>концентрирует внимание на семантические аспекты функционирования интеллектуальной системы и не содержит никаких лишних деталей, обусловленных тем или иным способом ее технической реализации (интерпретации);</li>
<li>является абстрактным инвариантом целого множества самых различных способов ее технологической реализации (в том числе и с помощью принципиально новых компьютеров).</li></ol>

<p>
Разработка прототипа интеллектуальной системы завершается разработкой полной sc-модели этой системы, которая записывается в виде исходного текста с использованием таких языковых средств, как SCg-код, SCs-код, SCn-код. После этого разработчик выбирает один из универсальных (!) вариантов интерпретации (реализации) sc-моделей, загружает разработанные им исходные тексты в выбранный интерпретатор и получает прототип, пригодный для опытной эксплуатации и последующего совершенствования.</p>

<p>
Если же после этого разработчиков интеллектуальной системы что-то не устраивает в выбранном варианте интерпретации sc-моделей (в частности, производительность), должна существовать достаточно продуманная методика совершенствования выбранного варианта интерпретатора sc-моделей интеллектуальных систем. Очевидно, что для каждого варианта интерпретации sc-моделей интеллектуальных систем указанная методика будет иметь свои особенности.</p>

<p>
Следовательно, нижние уровни детализации проектируемых интеллектуальных систем, в отличие от верхнего (логико-семантического) являются платформенно-зависимыми. Можно говорить о различных модификациях технологии проектирования интеллектуальных систем, соответствующих разным платформам. Напомним при этом, что основная трудоемкость проектирования интеллектуальных систем, полностью определяющая уровень ее возможностей (уровень знаний и навыков) концентрируется именно на 1-ом этапе проектирования – на разработке ее абстрактной логико-семантической модели.</p>

<p>
Таким образом, проектирование интеллектуальной системы можно организовать как два следующих самостоятельных процесса, выполняемых одновременно и независимо друг от друга:</p>

<ol>
<li>Процесс разработки абстрактной унифицированной логико-семантической модели проектируемой интеллектуальной системы;</li>
<li>Процесс совершенствования выбранного интерпретатора абстрактных унифицированных логико-семантических моделей интеллектуальных систем.</li></ol>

<p>
Заметим, что сама  идея обеспечения кросс-платформенной разработки компьютерных систем путем внедрения формального языка, обеспечивающего описание абстрактных (логических) моделей этих систем не нова. Существует целый ряд кросс-платформенных технологий. Вопрос в том (1) о каком классе разрабатываемых компьютерных систем идет речь, (2) какими свойствами обладают используемые абстрактные модели компьютерных систем, (3) какими достоинствами обладает технология разработки самих этих абстрактных моделей.</p>

<p>
Вопросы программной реализации и, в частности, web-ориентированной реализации унифицированных логико-семантических моделей интеллектуальных систем рассмотрены в работе [Колб, 2012].</p>

<p>
<b>18. Принцип ориентации на перспективную разработку принципиально новых платформ, основанных на аппаратной поддержке интерпретации платформенно независимых унифицированных логико-семантических моделей интеллектуальных систем</b></p>

<p>
Предлагается обеспечить возможность реализации унифицированных логико-семантических моделей интеллектуальных систем на <b>семантических ассоциативных параллельных компьютерах</b>, специально ориентированных на аппаратную реализацию таких моделей.</p>

<p>
Очевидно, что для указанных компьютеров базовый графовый язык программирования (язык SCP) является их ассемблером, т. е. аппаратно интерпретируемым языком программирования.</p>

<p>
В связи с проблемой создания компьютеров, ориентированных на обработку знаний, необходимо отметить следующее:</p>

<ol>
<li>В таких компьютерах принципиально важна поддержка именно параллельной обработки знаний;</li>
<li>Опыт использования параллельных компьютеров показывает, что эффективное их использование предполагающее разработку качественных параллельных программ требует особой профессиональной подготовки и высокой квалификации. Мир параллельного программирования требует особой культуры, особого стиля мышления. Еще более серьезная профессиональная подготовка требуется для разработки параллельных программ, ориентированных на обработку знаний и использующих ассоциативный доступ к обрабатываемой информации;</li>
<li>Уровень развития микроэлектронных технологий сейчас позволяет достаточно быстро реализовывать самые смелые компьютерные архитектуры и модели обработки информации. Необходима только четкая постановка задачи;</li>
<li>Созданию параллельных компьютеров для обработки знаний должно предшествовать создание <b>технологии</b> проектирования интеллектуальных систем, в основе которой лежат те модели параллельной обработки знаний, которые будут аппаратно поддерживаться в указанных компьютерах. Иначе мы получим "груду" талантливо сделанного "железа", эффективность использования которого будет, мягко говоря, весьма низкой. Это главная причина неудач такого рода проектов;</li>
<li>Предлагаемая технология проектирования интеллектуальных систем как раз и предполагает последовательное выполнение следующих этапов:</li>
<ul>
<li>разработка технологии проектирования абстрактных унифицированных логико-семантических моделей интеллектуальных систем;</li>
<li>разработка нескольких вариантов программной реализации абстрактных унифицированных логико-семантических моделей интеллектуальных систем, выполненных на современных компьютерах;</li>
<li>разработка, эксплуатация достаточно большого количества прикладных интеллектуальных систем и совершенствование технологии проектирования интеллектуальных систем на основе приобретенного опыта;</li>
<li>и только после этого разработка семантического ассоциативного компьютера, появление которого не отменит абсолютно ничего, сделанного ранее. Просто появится ёще один, но уже аппаратный вариант реализации абстрактных унифицированных логико-семантических моделей интеллектуальных систем, применение которого для уже разработанных абстрактных унифицированных логико-семантических моделей самых различных прикладных систем для конечных пользователей этих интеллектуальных систем абсолютно ничего не изменит, кроме существенного повышения быстродействия.</li></ul></ol>

<p>
Рассматривая абстрактную sc-машину обработки знаний на самом верхнем уровне, мы не уточняем (не детализируем) "внутреннее устройство" sc-агентов обработки знаний. Разработав язык SCP, мы получили возможность формально описывать (детализировать) поведение sc-агентов обработки знаний. Если трактовать язык SCP как ассемблер семантического ассоциативного компьютера, то проектирование этого компьютера можно рассматривать как формальный переход к sc-машинам более низкого уровня, обеспечивающим <u>интерпретацию sc-машин</u> более высокого уровня. Существенным здесь является то, что при этом мы не выходим за пределы класса абстрактных sc-машин. Просто вводится последовательность sc-языков программирования все более и более низкого уровня, каждый из которого обеспечивает формальное описание sc-агентов, входящих в состав sc-машины, интерпретирующей программы непосредственно предшествующего ему sc-языка программирования более высокого уровня (см. принцип 9). При этом число таких уровней, т. е. число таких специальных sc-языков программирования (которые можно назвать sc-языками микропрограммирования) должно быть столько, сколько необходимо для доведения формального описания sc-машин до такого уровня детализации, который позволяет перейти от соответствующего абстрактного языка микропрограммирования к формальному описанию цифровой аппаратуры на языке VHDL.</p>

<p>
Архитектуру аппаратной реализации семантических моделей обработки знаний можно рассматривать как иерархию абстрактных машин, описывающих переход от агентов, имеющих доступ ко всей семантической памяти, к агентам, имеющим доступ только к своей семантической  окрестности и, в конечном счете, взаимодействующим только со своими семантическими соседями.</p>

<p>
Аппаратная интерпретация абстрактных sc-машин предполагает создание реконфигурируемой памяти с распределенными в ней процессорными элементами. Такую интеграцию памяти и процессора будем называть <b>процессоро-памятью</b>. Реконфигурируемость (структурная перестраиваемость) памяти может быть обеспечена коммутационной средой для процессорных элементов. Можно рассматривать целый ряд подходов к реализации реконфигурируемой семантической ассоциативной процессоро-памяти. В частности, процессорным элементам можно ставить в соответствие узлы обрабатываемых унифицированных семантических сетей, а коммутируемым каналам связи между процессорными элементами – коннекторы этой семантической сети. В этом случае текущее состояние конфигурации коммутируемых каналов связи будет полностью соответствовать текущему состоянию конфигурации обрабатываемой семантической сети. Следовательно, память "превращается" из пассивного хранилища байтов в коммутационную среду между процессорными элементами.</p>

<p>
<b>19. Принцип унификации семантических моделей встроенных интеллектуальных систем, поддерживающих эффективную эксплуатацию, сопровождение и обновление тех автономных интеллектуальных систем, в состав которых они входят</b></p>

<p>
Каждую проектируемую интеллектуальную систему предлагается трактовать  как <b>результат интеграции следующих интеллектуальных подсистем:</b></p>

<ul>
<li>предметной (основной) интеллектуальной системы;</li>
<li>интеллектуального пользовательского интерфейса;</li>
<li>интеллектуальной подсистемы адаптивного управления диалогом с конечным пользователем;</li>
<li>интеллектуальной help-системы для информационного обслуживания и обучения конечных пользователей предметной интеллектуальной системы, которые, начиная работать с системой не обязаны иметь сразу высокую квалификацию;</li>
<li>интеллектуальные системы управления проектированием интеллектуальной системы, которая координирует деятельность разработчиков предметной интеллектуальной системы [Грибова, 2010];</li>
<li>интеллектуальные системы управления информационной безопасностью предметной интеллектуальной системы.</li></ul>

<p>
Подчеркнем, что для обеспечения интегрируемости (семантической совместимости) перечисленных интеллектуальных систем они должны проектироваться на основе <i>одной и той же технологии</i>.</p>

<p>
Таким образом, проектируя каждую интеллектуальную систему, необходимо одновременно проектировать:</p>

<ul>
<li>также и подсистему, которая осуществляет информационное обслуживание и обучение конечных пользователей данной интеллектуальной системы, т. е. фактически, является оформлением документации по эксплуатации системы в виде интеллектуальной справочной и обучающей системы. Это существенно расширит контингент конечных пользователей, повысит эффективность эксплуатации системы и существенно упростит эту эксплуатацию;</li>
<li>также и подсистему, которая обеспечивает координацию разработчиков проектируемой интеллектуальной системы, поскольку разработка (совершенствование) системы продолжается в ходе её эксплуатации и требует создания специальных методов и компьютерных средств постоянного совершенствования предметной интеллектуальной системы непосредственно в ходе её эксплуатации. Это существенно отодвинет срок её морального старения;</li>
<li>также и подсистему, обеспечивающую управление информационной безопасности проектируемой интеллектуальной системы.</li></ul>

<p>
Если подсистема управления проектированием интеллектуальной системы будет создаваться действительно как интеллектуальная система, интегрируемая с основной (предметной) интеллектуальной системой, то в перспективе она может стать не только координатором деятельности разработчиков, но и самостоятельным субъектом проектирования, способным тестировать, диагностировать, анализировать как основную проектируемую интеллектуальную систему, так и самоё себя.</p>

<p>
<b>20. Принцип рефлексивности интеллектуальных систем, разрабатываемых по Технологии OSTIS</b></p>

<p>
Данный принцип означает то, что в базу знаний каждой интеллектуальной системы, разрабатываемой по Технологии OSTIS, включается полная документация этой интеллектуальной системы (полное описание себя самой). </p>

<p>
Наличие такой документации обеспечивает:</p>

<ul>
<li>качественное информационное обслуживание конечных пользователей по вопросам эксплуатации интеллектуальной системы;</li>
<li>качественное информационное обслуживание разработчиков, которые осуществляют перманентное совершенствование интеллектуальной системы в ходе ее эксплуатации;</li>
<li>возможность адекватной самооценки (оценки своих возможностей при планировании собственных действий);</li>
<li>возможность конструктивного анализа собственной деятельности и выявления своих недостатков.</li></ul>

<p>
<b>21. Принцип доступности и открытости технологии как для ее использования, так и для ее совершенствования</b></p>

<p>
Предлагается обеспечить максимально возможное <b>расширение контингента разработчиков</b> интеллектуальных систем, использующих предлагаемую технологию, за счет максимальной доступности этой технологии и открытого характера её развития.</p>

<p>
Доступность технологии проектирования интеллектуальных систем прежде всего означает то, что в ее основе должна лежать такая модель представления и обработки знаний, которая была бы комфортна не только для средств технической реализации этой модели, но и комфортна для человека (для конечного пользователя и разработчика). Комфортность для человека в данном случае – это понятность, человекоподобность (в широком смысле).</p>

<p>
Вычурные неестественные для человеческого восприятия модели представления и обработки знаний не могут быть доступными для понимания широкого круга пользователей и широкого круга разработчиков.</p>

<p>
Если технология проектирования интеллектуальных систем ориентируется на широкое, массовое распространение и на интенсивное собственное развитие, опирающееся на накапливаемый опыт её использования, она должна быть доступной и открытой. Это означает:</p>

<ul>
<li>свободный доступ к всей документации и основанным средствам автоматизации (компьютерной поддержки) проектирования интеллектуальных систем;</li>
<li>открытость исходных текстов всех основных средств компьютерной поддержки проектирования интеллектуальных систем, всех основных многократно используемых (типовых) компонентов интеллектуальных систем;</li>
<li>открытость исходных текстов всех "пилотных" проектов прикладных интеллектуальных систем, выполняющих роль "образцово-показательных" проектов;</li>
<li>открытый характер организации (project-менеджмента) процесса развития технологии, имеющий форму открытого (open source) проекта, участником которого может быть любой желающий, в том числе, и любой пользователь этой технологии, указывающий на различные ошибки и высказывающий различные пожелания.</li></ul>

<p>
Завершая рассмотрение открытого характера предлагаемой технологии, сделаем следующие замечания:</p>

<ul>
<li>открытый характер технологии не является препятствием для реализации коммерческих интересов, связанных с этой технологией. Так, например, на коммерческой основе могут создаваться и предоставляться</li>
<ol>
<li>самые различные прикладные интеллектуальные системы,</li>
<li>некоторые варианты реализации различных многократно используемых (типовых) компонентов интеллектуальных систем,</li>
<li>некоторые варианты реализации интерпретатора абстрактных семантических логико-семантических моделей интеллектуальных систем, в частности, различные варианты построения семантических ассоциативных параллельных компьютеров;</li></ol>
<li>открытый характер технологии, при грамотном использовании фактора её открытости, способствует обеспечению информационной безопасности, как самой технологии, так и прикладных интеллектуальных систем, созданных на её основе;</li>
<li>открытый характер предлагаемой технологии проектирования интеллектуальных систем может быть эффективно реализован только на базе <b>технологии облачных вычислений</b>, в рамках которой вся предлагаемая технология проектирования интеллектуальных систем рассматривается как некий Internet-сервис [Грибова и др., 2011]</li></ul>

<p>
<b>22. Принцип ориентации на методику эволюционного проектирования интеллектуальных систем</b></p>

<p>
Предлагается использовать <b>методику поэтапного эволюционного проектирования</b> интеллектуальных систем.</p>

<p>
Указанная методика предполагает:</p>

<ul>
<li>быстрое проектирование;</li>
<li>скорейшее введение в эксплуатацию первых версий проектируемой системы с минимальными, но практически полезными возможностями;</li>
<li>эволюционное поэтапное совершенствование проектируемой интеллектуальной системы путем её расширения новыми знаниями и навыками непосредственно в ходе эксплуатации интеллектуальной системы и активным привлечением её конечных пользователей.</li></ul>

<p>
С формальной точки зрения проектирование унифицированной логико-семантической модели (sc-модели) интеллектуальной системы в конечном счете сводится к проектированию sc-модели <b>базы знаний</b> этой интеллектуальной системы, поскольку scp-программы, описывающие поведение sc-агентов, можно рассматривать как часть базы знаний. Таким образом, проектируемая база знаний включает в себя:</p>

<ul>
<li>базу знаний предметной (основной) интеллектуальной системы;</li>
<li>тексты всех scp-программ, описывающих поведение sc-агентов;</li>
<li>текст документации, представленный в виде базы знаний интеллектуальной help-системы, обеспечивающей всестороннее информационное обслуживание пользователей проектируемой интеллектуальной системы.</li></ul>

<p>
Начальный этап проектирования базы знаний интеллектуальной системы – это уточнение иерархической системы предметных областей, которые должны быть описаны в проектируемой базы знаний. Каждой такой предметной области ставится в соответствие определенный раздел проектируемой базы знаний. Среди выделенных разделов проектируемой базы знаний имеются разделы, которые делятся (декомпозируются) на подразделы, а также атомарные (недекопозируемые) разделы. Далее процесс проектирования всей базы знаний сводится к проектированию каждого её атомарного раздела с последующей их интеграцией в единую базу знаний.</p>

<p>
В целом начальную стадию проектирования всей интеллектуальной системы на основе предлагаемой технологии условно разбить на следующие четыре этапа:</p>

<ol>
<li>Разработка 1-й версии интеллектуальной системы, которая включает в себя:</li><ul>
<li>1-ю версию её базы знаний;</li>
<li><u>типовое ядро</u> интеллектуальной информационно-поисковой машины, которое входит в состав библиотеки многократно используемых компонентов интеллектуальных систем;</li>
<li><u>типовое ядро</u> интеллектуального решателя, которое входит в состав библиотеки многократно используемых компонентов интеллектуальных систем;</li>
<li><u>типовое ядро</u> пользовательского интерфейса, которое входит в состав библиотеки многократно используемых компонентов интеллектуальных систем.</li></ul>

	<p>Разработанная 1-я версия интеллектуальной системы уже обладает определенной целостностью, её можно тестировать и запускать в предварительную опытную эксплуатацию.</p>
<li>Разработка 2-й версии интеллектуальной системы, которая включает в себя:</li><ul>
<li>2-ю версию её базы знаний;</li>
<li>1-ю версию её информационно-поисковой машины;</li>
<li>типовое ядро её интеллектуального решателя;</li>
<li>типовое ядро её пользовательского интерфейса;</li></ul>
<li>Разработка 3-й версии интеллектуальной системы, включающей в себя:</li><ul>
<li>3-ю версию её базы знаний;</li>
<li>2-ю версию её информационно-поисковой машины;</li>
<li>1-ю версию её интеллектуального решателя;</li>
<li>типовое ядро её пользовательского интерфейса;</li></ul>
<li>Разработка 4-й версии интеллектуальной систем, включающей в себя:</li><ul>
<li>4-ю версию её базы знаний;</li>
<li>3-ю версию её информационно-поисковой машины;</li>
<li>2-ю версию её интеллектуального решателя;</li>
<li>1-ю версию её пользовательского интерфейса.</li></ul></ol>

<p>
Дальнейшее развитие проектируемой интеллектуальной системы может акцентировать внимание на самых разных направлениях, приоритетность которых определяется самим приложением.</p>

<p>
Более подробно методика эволюционного коллективного проектирования унифицированных семантических моделей интеллектуальных систем, на основе содержательной структуризации знаний (см. принцип 6), описана в работе [Давыденко, 2012]</p>

<p>
<b>23. Принцип реализации предлагаемой технологии проектирования интеллектуальных систем в виде интеллектуальной метасистемы, которая строится по той же предлагаемой технологии и обеспечивает комплексную информационную и функциональную поддержку проектирования интеллектуальных систем</b></p>

<p>
Предлагается реализовать рассматриваемую технологию как <b>интеллектуальную метасистему ориентированную на поддержку проектирования интеллектуальных систем</b> построенную по тем же самым принципам (т. е. по той же технологии), что и интеллектуальные системы, разрабатываемые на её основе.</p>

<p>
Указанная интеллектуальная система должна включать в себя:</p>

<ul>
<li>теорию (принципы построения) проектируемых интеллектуальных систем, которая входит в состав базы знаний метасистемы;</li>
<li>библиотеку типовых многократно используемых компонентов (ip-компонентов) интеллектуальных систем, которая входит в состав базы знаний рассматриваемой метасистемы;</li>
<li>средства автоматизации синтеза, анализа и имитационного моделирования проектируемых интеллектуальных систем и их компонентов (это подсистема интеллектуальной метасистемы, ориентированная на решение задач проектирования интеллектуальных систем);</li>
<li>интеллектуальную help-систему, являющуюся подсистемой рассматриваемой интеллектуальной метасистемы ориентированной на информационное обслуживание и обучение разработчиков интеллектуальных систем;</li>
<li>методику проектирования интеллектуальных систем, которая оформляется как часть базы знаний метасистемы;</li>
<li>методику обучения проектированию интеллектуальной системы, которая также является частью базы знаний метасистемы;</li>
<li>интеллектуальную подсистему управления проектированием самой метасистемы;</li>
<li>интеллектуальную подсистему управления информационной безопасностью метасистемы;</li>
<li>семейство различных вариантов реализации интерпретаторов унифицированных абстрактных логико-семантических моделей интеллектуальных систем.</li></ul>

<p>
Учитывая рассматриваемые выше принципы построения предлагаемой нами технологии, она названа Открытой Семантической Технологией проектирования Интеллектуальных Систем (Open Semantic Technology for Intelligent Systems – OSTIS). Можно также её было бы назвать <b>SC-технологией</b>, поскольку основой этой технологии является SC-код. Соответственно этому, интеллектуальную метасистему, ориентированную на поддержку проектирования интеллектуальных систем, будем называть <b>метасистемой OSTIS</b>.</p>

<p>
В интеллектуальной метасистеме OSTIS можно выделить целый ряд подсистем, ориентированных на поддержку проектирования различных компонентов интеллектуальных систем, таких, как:</p>

<ul>
<li>базы знаний и различные фрагменты баз знаний (онтологии, формальные теории, программы);</li>
<li>информационно-поисковые машины, машины интеграции знаний, решатели задач;</li>
<li>пользовательские интерфейсы (графические, естественно-языковые, мультимодальные).</li></ul>

<p>
В интеллектуальной метасистеме OSTIS можно также выделить семейство интеллектуальных подсистем, ориентированных на поддержку проектирования различных классов интеллектуальных система, таких, как:</p>

<ul>
<li>интеллектуальные справочные системы (системы информационного обслуживания);</li>
<li>интеллектуальные обучающие системы (имеющие подсистемы интеллектуального управления обучением);</li>
<li>интеллектуальные help-системы для пользователей различных компьютерных систем;</li>
<li>интеллектуальные системы автоматизированного проектирования;</li>
<li>интеллектуальные системы управления проектами.</li></ul>